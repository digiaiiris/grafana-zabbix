{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"react\"","webpack:///external \"lodash\"","webpack:///./datasource-zabbix/utils.ts","webpack:///./datasource-zabbix/constants.js","webpack:///./datasource-zabbix/types.ts","webpack:///external \"moment\"","webpack:///external \"@grafana/runtime\"","webpack:///external \"jquery\"","webpack:///external \"@grafana/ui\"","webpack:///external \"app/core/utils/datemath\"","webpack:///external \"app/plugins/sdk\"","webpack:///external \"app/core/utils/kbn\"","webpack:///external \"angular\"","webpack:///external \"app/core/core_module\"","webpack:///external \"app/core/table_model\"","webpack:///external \"emotion\"","webpack:///external \"app/core/config\"","webpack:///./datasource-zabbix/migrations.ts","webpack:///./datasource-zabbix/metricFunctions.js","webpack:///./datasource-zabbix/timeseries.js","webpack:///./datasource-zabbix/dataProcessor.js","webpack:///./datasource-zabbix/responseHandler.js","webpack:///./datasource-zabbix/zabbix/proxy/cachingProxy.js","webpack:///./datasource-zabbix/zabbix/connectors/dbConnector.js","webpack:///./datasource-zabbix/zabbix/connectors/zabbix_api/zabbixAPICore.js","webpack:///./datasource-zabbix/zabbix/connectors/zabbix_api/zabbixAPIConnector.js","webpack:///./datasource-zabbix/zabbix/connectors/sql/mysql.js","webpack:///./datasource-zabbix/zabbix/connectors/sql/postgres.js","webpack:///./datasource-zabbix/zabbix/connectors/sql/sqlConnector.js","webpack:///./datasource-zabbix/zabbix/connectors/influxdb/influxdbConnector.js","webpack:///./datasource-zabbix/zabbix/zabbix.js","webpack:///./datasource-zabbix/datasource.js","webpack:///./datasource-zabbix/query.controller.js","webpack:///./datasource-zabbix/config.controller.js","webpack:///./datasource-zabbix/components/ZabbixInput.tsx","webpack:///./datasource-zabbix/components/VariableQueryEditor.tsx","webpack:///./datasource-zabbix/zabbixAlerting.service.js","webpack:///./datasource-zabbix/add-metric-function.directive.js","webpack:///./datasource-zabbix/react2angular.ts","webpack:///./datasource-zabbix/components/FunctionEditorControls.tsx","webpack:///./datasource-zabbix/components/FunctionEditor.tsx","webpack:///./datasource-zabbix/metric-function-editor.directive.ts","webpack:///./datasource-zabbix/module.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","variableRegex","expandItemName","paramStr","params","quoted","in_array","param","key_params_str","substring","indexOf","lastIndexOf","key_params","forEach","symbol","push","length","replace","expandItems","items","item","key_","MACRO_PATTERN","containsMacro","itemName","test","replaceMacro","macros","item_macros","match","macro","host_macros","filter","hostid","macro_def","find","macro_value","macro_regex","RegExp","escapeMacro","parseLegacyVariableQuery","query","queryType","parts","each","split","isContainsBraces","result","map","part","trim","splitTemplateQuery","template","zipObject","app","Group","Host","Application","Item","group","host","application","regexPattern","isRegex","str","isTemplateVariable","templateVariables","variables","variable","includes","getRangeScopedVars","range","msRange","to","diff","from","sRange","Math","round","regularRange","secondsToHms","__range_ms","text","__range_s","__range","__range_series","buildRegex","matches","pattern","flags","undefined","escapeRegex","parseInterval","interval","momentInterval","exec","duration","Number","valueOf","parseTimeShiftInterval","formatAcknowledges","acknowledges","ack","unix","clock","format","alias","surname","message","concat","sequence","funcsArray","this","versionPattern","parseVersion","version","major","minor","patch","meta","compactQuery","getArrayDepth","a","level","elem","isArray","contains","DATAPOINT_TS","MODE_METRICS","MODE_ITSERVICE","MODE_TEXT","MODE_ITEMID","MODE_TRIGGERS","SEV_WARNING","SHOW_ALL_TRIGGERS","SHOW_ALL_EVENTS","SHOW_OK_EVENTS","ZBX_ACK_ACTION_NONE","ZBX_ACK_ACTION_ACK","ZBX_ACK_ACTION_ADD_MESSAGE","TRIGGER_SEVERITY","val","MIN_SLA_INTERVAL","RANGE_VARIABLE_VALUE","VariableQueryTypes","__WEBPACK_EXTERNAL_MODULE__8__","__WEBPACK_EXTERNAL_MODULE__10__","__WEBPACK_EXTERNAL_MODULE__11__","__WEBPACK_EXTERNAL_MODULE__12__","__WEBPACK_EXTERNAL_MODULE__13__","__WEBPACK_EXTERNAL_MODULE__14__","__WEBPACK_EXTERNAL_MODULE__17__","__WEBPACK_EXTERNAL_MODULE__18__","__WEBPACK_EXTERNAL_MODULE__21__","__WEBPACK_EXTERNAL_MODULE__22__","__WEBPACK_EXTERNAL_MODULE__23__","__WEBPACK_EXTERNAL_MODULE__25__","target","f","def","jsonData","dbConnection","categories","Transform","Aggregate","Filter","Trends","Time","Alias","Special","funcDef","defaultParams","index","shortName","category","type","catName","_","sortBy","funcList","func","parameters","paramType","strValue","partVal","splice","join","isString","POINT_TIMESTAMP","datapoints","groupByRange","point","frame_ts","grouped_series","frame_values","frame_value","point_frame_ts","getPointTimeFrame","groupByCallback","ms_interval","frame_start","frame_end","values","sum","timestamp","left","series","findNearestLeft","right","findNearestRight","downsample","groupBy","downsampledSeries","timeWindow","time_to","points_num","value_avg","frame","points_sum","groupBy_perf","utils","sumSeries","scale","new_timestamps","append","new_point","timestamps","prepend","new_series","interpolated_timeseries","offset","scale_perf","POINT_VALUE","delta","rate","deltaValue","newSeries","simpleMovingAverage","valueDelta","point_prev","timeDelta","expMovingAverage","w_avg","w_sum","w_count","SUM","ema_prev","ema_cur","ema","COUNT","AVERAGE","MIN","values_non_null","MAX","MEDIAN","PERCENTILE","sortByTime","flattenDatapoints","ts","groupBy_exported","orderByCallback","aggregationFunctions","sortByIteratee","order","sortedTimeseries","flattenedPoints","movingAverage","exponentialMovingAverage","percentile","transformNull","aggregateBy","aggregateFunc","sortedPoints","average","partial","min","aggregateWrapper","max","median","count","removeAboveValue","removeBelowValue","top","bottom","limit","sortSeries","timeShift","direction","setAlias","setAliasByRegex","timeseries","replaceAlias","extractText","extractPattern","avg","downsampleSeries","unShiftTimeSeries","dp","hosts","itemid","extractedValue","handleHistory","convertHistory","convertHistoryPoint","handleTrends","handleText","convertPointCallback","convertTrendPoint","valueType","history","handleHistoryAsTable","convertTextCallback","convertText","handleSLAResponse","TableModel","table","addColumn","grouped_history","lastPoint","itemHistory","lastValue","handleTriggersResponse","serviceid","sla","slaProperty","targetStatus","slaArr","sortTimeseries","triggers","stats","groupNames","groups","trigger","priority","severity","row","rows","triggersCount","console","cacheEnabled","cacheOptions","enabled","ttl","promises","cacheRequest","self","cache","funcName","hash","getRequestHash","arguments","Promise","cacheObject","funcScope","promiseKeeper","then","proxyfied","object_age","argsJson","stringify","getHash","chr","charCodeAt","HISTORY_TO_TABLE_MAP","datasourceId","datasourceName","options","datasourceTypeId","datasourceTypeName","DBConnector","ds","convertGrafanaTSResponse","addHostName","methodName","code","grafanaSeries","compact","DEFAULT_QUERY_LIMIT","TREND_TO_TABLE_MAP","consolidateByFunc","consolidateByTrendColumns","api_url","requestData","jsonrpc","method","id","url","data","headers","requestOptions","withCredentials","response","error","username","password","user","auth","basicAuth","loginErrorCount","maxLoginAttempts","zabbixAPICore","request","isNotAuthorized","loginPromise","login","eventid","action","eventids","sortfield","real_hosts","output","hostids","appids","webitems","selectHosts","itemids","globalmacro","timeFrom","grouped_items","sortorder","time_from","trend","value_type","serviceids","intervals","buildSLAIntervals","timeRange","slaInterval","getSLAInterval","intervalMs","kbn","timeTo","ceil","showTriggers","maintenance","groupids","applicationids","expandDescription","expandData","expandComment","monitored","skipDependent","selectItems","selectLastEvent","selectTags","lastChangeSince","lastChangeTill","time_till","objectids","select_acknowledges","showEvents","preservekeys","events","minSeverity","min_severity","selectGroups","countOutput","filterTriggersByAcknowledge","acknowledged","historyQuery","trendsQuery","intervalSec","time_expression","timeTill","testQuery","ITEMID_FORMAT","mysql","sqlDialect","postgres","invokeSQLQuery","consolidateBy","results","valueColumn","dbConnector","refId","rawSql","maxDataPoints","queries","buildHistoryQuery","invokeInfluxDBQuery","handleInfluxHistoryResponse","influxSeries","points","retentionPolicy","measurement","where_clause","itemidsWhere","cacheTTL","cacheRequests","bindRequests","dbConnectionRetentionPolicy","dbConnectionDatasourceId","dbConnectionDatasourceName","getTrendsDB","cachingProxy","proxyfyWithCache","getTrends","loadDatasource","connectorOptions","InfluxDBConnector","REQUESTS_TO_PROXYFY","zabbixAPI","proxyfy","REQUESTS_TO_CACHE","REQUESTS_TO_BIND","dbConnectorStatus","zabbixVersion","resolve","testResult","dsType","dsName","getItems","filters","getHosts","getApps","appFilterEmpty","apps","groupFilter","getGroups","hostFilter","appFilter","filterByQuery","showDisabledItems","getMacros","itemFilter","itServices","filteredGroups","filterTriggersByProxy","proxyFilter","proxies","proxy","filtered","proxy_ids","findByFilter","enableDirectDBConnection","responseHandler","getTrend","resultFormat","itservices","isOldVersion","slaResponse","itservice","filterPattern","zbx_obj","finded","zabbixAlertingSrv","enableDebugLog","config","instanceSettings","migrations","trendsRange","alertingMinSeverity","zabbixOptions","templateSrv","alertingEnabled","removeZabbixThreshold","panelId","thresholds","timeFunctions","useTrends","isUseTrends","queryITServiceData","queryTriggersData","queryTextData","queryStart","getItemOptions","itemtype","Date","zabbix","queryEnd","debug","getHistoryPromise","getTrendValueType","getHistoryTS","dataProcessor","trendFunctions","trendValueFunc","timeseries_data","filterFunctions","bindFunctionDefs","functions","aliasFunctions","aggFuncNames","metricFunctions","timeShiftFunc","queryNumericDataForItems","itServiceFilter","itservicesdp","getHostsFromTarget","getHostAlerts","testDataSource","title","status","getVersion","resultPromise","queryModel","dateMath","annotation","showOkEvents","hideHostsInMaintenance","replaceTemplateVars","triggersOptions","triggerName","getEvents","indexedTriggers","event","tags","formatted_acknowledges","time","enabled_targets","filterEnabledTargets","getPanelItems","cloneDeep","replaceTargetVariables","firedTriggers","expression","finded_thresholds","threshold","state","toString","scopedVars","useTrendsFrom","useTrendsRange","trends","aggFuncDefs","bindFunction","expandable","replacedTarget","editorModes","$scope","editorMode","ITSERVICE","ITEMID","TRIGGERS","slaPropertyList","ackFilters","resultFormats","getGroupNames","getMetricNames","getItemNames","getITServices","getVariables","getTemplateVariables","$rootScope","onVariableChange","init","metric","queryOptionsText","scopeDefaults","initFilters","$injector","suggestGroups","suggestHosts","suggestApps","suggestItems","addAllValue","metrics","getAllGroups","hostList","appList","newTarget","targetChanged","isContainsVariables","field","newFunc","moveAliasFuncLast","aliasFunc","showQueryOptions","renderQueryOptionsText","optionsMap","defaultConfig","alerting","addThresholds","disableReadOnlyUsersAck","ZabbixDSConfigController","current","getSupportedDBDataSources","autoDetectZabbixVersion","loadCurrentDBDatasource","getDataSourceSrv","getAll","dsId","zabbixVersions","inputClass","styles","label","className","getDashboardModel","angular","panelIndex","panelModels","alertClass","$","panelContainers","getPanelModels","containsThreshold","panel","thresholdOptions","colorMode","line","lineColor","op","source","inputTemplate","functionMenu","createFunctionDropDownMenu","$input","appendTo","submenu","click","typeahead","allFunctions","updater","toLowerCase","$button","keyup","toggleClass","blur","removeClass","$compile","contents","$link","paramValue","component"],"mappings":"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","file":"datasource-zabbix/module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 40);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","import _ from 'lodash';\nimport moment from 'moment';\nimport kbn from 'grafana/app/core/utils/kbn';\nimport * as c from './constants';\nimport { VariableQuery, VariableQueryTypes } from './types';\n\n/*\n * This regex matches 3 types of variable reference with an optional format specifier\n * \\$(\\w+)                          $var1\n * \\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]    [[var2]] or [[var2:fmt2]]\n * \\${(\\w+)(?::(\\w+))?}             ${var3} or ${var3:fmt3}\n */\nexport const variableRegex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]|\\${(\\w+)(?:\\.([^:^\\}]+))?(?::(\\w+))?}/g;\n\n/**\n * Expand Zabbix item name\n *\n * @param  {string} name item name, ie \"CPU $2 time\"\n * @param  {string} key  item key, ie system.cpu.util[,system,avg1]\n * @return {string}      expanded name, ie \"CPU system time\"\n */\nexport function expandItemName(name, key) {\n\n  // extract params from key:\n  // \"system.cpu.util[,system,avg1]\" --> [\"\", \"system\", \"avg1\"]\n  const key_params_str = key.substring(key.indexOf('[') + 1, key.lastIndexOf(']'));\n  const key_params = splitKeyParams(key_params_str);\n\n  // replace item parameters\n  for (let i = key_params.length; i >= 1; i--) {\n    name = name.replace('$' + i, key_params[i - 1]);\n  }\n  return name;\n}\n\nexport function expandItems(items) {\n  _.forEach(items, item => {\n    item.item = item.name;\n    item.name = expandItemName(item.item, item.key_);\n    return item;\n  });\n  return items;\n}\n\nfunction splitKeyParams(paramStr) {\n  const params = [];\n  let quoted = false;\n  let in_array = false;\n  const split_symbol = ',';\n  let param = '';\n\n  _.forEach(paramStr, symbol => {\n    if (symbol === '\"' && in_array) {\n      param += symbol;\n    } else if (symbol === '\"' && quoted) {\n      quoted = false;\n    } else if (symbol === '\"' && !quoted) {\n      quoted = true;\n    } else if (symbol === '[' && !quoted) {\n      in_array  = true;\n    } else if (symbol === ']' && !quoted) {\n      in_array = false;\n    } else if (symbol === split_symbol && !quoted && !in_array) {\n      params.push(param);\n      param = '';\n    } else {\n      param += symbol;\n    }\n  });\n\n  params.push(param);\n  return params;\n}\n\nconst MACRO_PATTERN = /{\\$[A-Z0-9_\\.]+}/g;\n\nexport function containsMacro(itemName) {\n  return MACRO_PATTERN.test(itemName);\n}\n\nexport function replaceMacro(item, macros) {\n  let itemName = item.name;\n  const item_macros = itemName.match(MACRO_PATTERN);\n  _.forEach(item_macros, macro => {\n    const host_macros = _.filter(macros, m => {\n      if (m.hostid) {\n        return m.hostid === item.hostid;\n      } else {\n        // Add global macros\n        return true;\n      }\n    });\n\n    const macro_def = _.find(host_macros, { macro: macro });\n    if (macro_def && macro_def.value) {\n      const macro_value = macro_def.value;\n      const macro_regex = new RegExp(escapeMacro(macro));\n      itemName = itemName.replace(macro_regex, macro_value);\n    }\n  });\n\n  return itemName;\n}\n\nfunction escapeMacro(macro) {\n  macro = macro.replace(/\\$/, '\\\\\\$');\n  return macro;\n}\n\nexport function parseLegacyVariableQuery(query: string): VariableQuery {\n  let queryType: VariableQueryTypes;\n  const parts = [];\n\n  // Split query. Query structure: group.host.app.item\n  _.each(splitTemplateQuery(query), part => {\n    // Replace wildcard to regex\n    if (part === '*') {\n      part = '/.*/';\n    }\n    parts.push(part);\n  });\n  const template = _.zipObject(['group', 'host', 'app', 'item'], parts);\n\n  if (parts.length === 4 && template.app === '/.*/') {\n    // Search for all items, even it's not belong to any application\n    template.app = '';\n  }\n\n  switch (parts.length) {\n    case 1:\n      queryType = VariableQueryTypes.Group;\n      break;\n    case 2:\n      queryType = VariableQueryTypes.Host;\n      break;\n    case 3:\n      queryType = VariableQueryTypes.Application;\n      break;\n    case 4:\n      queryType = VariableQueryTypes.Item;\n      break;\n  }\n\n  const variableQuery: VariableQuery = {\n    queryType,\n    group: template.group || '',\n    host: template.host || '',\n    application: template.app || '',\n    item: template.item || '',\n  };\n\n  return variableQuery;\n}\n\n/**\n * Split template query to parts of zabbix entities\n * group.host.app.item -> [group, host, app, item]\n * {group}{host.com} -> [group, host.com]\n */\nexport function splitTemplateQuery(query) {\n  const splitPattern = /\\{[^\\{\\}]*\\}|\\{\\/.*\\/\\}/g;\n  let split;\n\n  if (isContainsBraces(query)) {\n    const result = query.match(splitPattern);\n    split = _.map(result, part => {\n      return _.trim(part, '{}');\n    });\n  } else {\n    split = query.split('.');\n  }\n\n  return split;\n}\n\nfunction isContainsBraces(query) {\n  const bracesPattern = /^\\{.+\\}$/;\n  return bracesPattern.test(query);\n}\n\n// Pattern for testing regex\nexport const regexPattern = /^\\/(.*)\\/([gmi]*)$/m;\n\nexport function isRegex(str) {\n  return regexPattern.test(str);\n}\n\nexport function isTemplateVariable(str, templateVariables) {\n  const variablePattern = /^\\$\\w+/;\n  if (variablePattern.test(str)) {\n    const variables = _.map(templateVariables, variable => {\n      return '$' + variable.name;\n    });\n    return _.includes(variables, str);\n  } else {\n    return false;\n  }\n}\n\nexport function getRangeScopedVars(range) {\n  const msRange = range.to.diff(range.from);\n  const sRange = Math.round(msRange / 1000);\n  const regularRange = kbn.secondsToHms(msRange / 1000);\n  return {\n    __range_ms: { text: msRange, value: msRange },\n    __range_s: { text: sRange, value: sRange },\n    __range: { text: regularRange, value: regularRange },\n    __range_series: {text: c.RANGE_VARIABLE_VALUE, value: c.RANGE_VARIABLE_VALUE},\n  };\n}\n\nexport function buildRegex(str) {\n  const matches = str.match(regexPattern);\n  const pattern = matches[1];\n  const flags = matches[2] !== \"\" ? matches[2] : undefined;\n  return new RegExp(pattern, flags);\n}\n\n// Need for template variables replace\n// From Grafana's templateSrv.js\nexport function escapeRegex(value) {\n  return value.replace(/[\\\\^$*+?.()|[\\]{}\\/]/g, '\\\\$&');\n}\n\nexport function parseInterval(interval) {\n  const intervalPattern = /(^[\\d]+)(y|M|w|d|h|m|s)/g;\n  const momentInterval: any[] = intervalPattern.exec(interval);\n  return moment.duration(Number(momentInterval[1]), momentInterval[2]).valueOf();\n}\n\nexport function parseTimeShiftInterval(interval) {\n  const intervalPattern = /^([\\+\\-]*)([\\d]+)(y|M|w|d|h|m|s)/g;\n  const momentInterval: any[] = intervalPattern.exec(interval);\n  let duration: any = 0;\n\n  if (momentInterval[1] === '+') {\n    duration = 0 - (moment.duration(Number(momentInterval[2]), momentInterval[3]).valueOf() as any);\n  } else {\n    duration = moment.duration(Number(momentInterval[2]), momentInterval[3]).valueOf();\n  }\n\n  return duration;\n}\n\n/**\n * Format acknowledges.\n *\n * @param  {array} acknowledges array of Zabbix acknowledge objects\n * @return {string} HTML-formatted table\n */\nexport function formatAcknowledges(acknowledges) {\n  if (acknowledges.length) {\n    let formatted_acknowledges = '<br><br>Acknowledges:<br><table><tr><td><b>Time</b></td>'\n      + '<td><b>User</b></td><td><b>Comments</b></td></tr>';\n    _.each(_.map(acknowledges, ack => {\n      const timestamp = moment.unix(ack.clock);\n      return '<tr><td><i>' + timestamp.format(\"DD MMM YYYY HH:mm:ss\") + '</i></td><td>' + ack.alias\n        + ' (' + ack.name + ' ' + ack.surname + ')' + '</td><td>' + ack.message + '</td></tr>';\n    }), ack => {\n      formatted_acknowledges = formatted_acknowledges.concat(ack);\n    });\n    formatted_acknowledges = formatted_acknowledges.concat('</table>');\n    return formatted_acknowledges;\n  } else {\n    return '';\n  }\n}\n\nexport function convertToZabbixAPIUrl(url) {\n  const zabbixAPIUrlPattern = /.*api_jsonrpc.php$/;\n  const trimSlashPattern = /(.*?)[\\/]*$/;\n  if (url.match(zabbixAPIUrlPattern)) {\n    return url;\n  } else {\n    return url.replace(trimSlashPattern, \"$1\");\n  }\n}\n\n/**\n * Wrap function to prevent multiple calls\n * when waiting for result.\n */\nexport function callOnce(func, promiseKeeper) {\n  return function() {\n    if (!promiseKeeper) {\n      promiseKeeper = Promise.resolve(\n        func.apply(this, arguments)\n        .then(result => {\n          promiseKeeper = null;\n          return result;\n        })\n      );\n    }\n    return promiseKeeper;\n  };\n}\n\n/**\n * Apply function one by one: `sequence([a(), b(), c()]) = c(b(a()))`\n * @param {*} funcsArray functions to apply\n */\nexport function sequence(funcsArray) {\n  return function(result) {\n    for (let i = 0; i < funcsArray.length; i++) {\n      result = funcsArray[i].call(this, result);\n    }\n    return result;\n  };\n}\n\nconst versionPattern = /^(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?(?:-([0-9A-Za-z\\.]+))?/;\n\nexport function isValidVersion(version) {\n  return versionPattern.exec(version);\n}\n\nexport function parseVersion(version) {\n  const match = versionPattern.exec(version);\n  if (!match) {\n    return null;\n  }\n  const major = Number(match[1]);\n  const minor = Number(match[2] || 0);\n  const patch = Number(match[3] || 0);\n  const meta = match[4];\n  return { major, minor, patch, meta };\n}\n\n/**\n * Replaces any space-like symbols (tabs, new lines, spaces) by single whitespace.\n */\nexport function compactQuery(query) {\n  return query.replace(/\\s+/g, ' ').trim();\n}\n\nexport function getArrayDepth(a, level = 0) {\n  if (a.length === 0) {\n    return 1;\n  }\n  const elem = a[0];\n  if (_.isArray(elem)) {\n    return getArrayDepth(elem, level + 1);\n  }\n  return level + 1;\n}\n\n// Fix for backward compatibility with lodash 2.4\nif (!_.includes) {\n  _.includes = (_ as any).contains;\n}\n","// Data point\nexport const DATAPOINT_VALUE = 0;\nexport const DATAPOINT_TS = 1;\n\n// Editor modes\nexport const MODE_METRICS = 0;\nexport const MODE_ITSERVICE = 1;\nexport const MODE_TEXT = 2;\nexport const MODE_ITEMID = 3;\nexport const MODE_TRIGGERS = 4;\n\n// Triggers severity\nexport const SEV_NOT_CLASSIFIED = 0;\nexport const SEV_INFORMATION = 1;\nexport const SEV_WARNING = 2;\nexport const SEV_AVERAGE = 3;\nexport const SEV_HIGH = 4;\nexport const SEV_DISASTER = 5;\n\nexport const SHOW_ALL_TRIGGERS = [0, 1];\nexport const SHOW_ALL_EVENTS = [0, 1];\nexport const SHOW_OK_EVENTS = 1;\n\n// Acknowledge\nexport const ZBX_ACK_ACTION_NONE = 0;\nexport const ZBX_ACK_ACTION_ACK = 2;\nexport const ZBX_ACK_ACTION_ADD_MESSAGE = 4;\n\nexport const TRIGGER_SEVERITY = [\n  {val: 0, text: 'Not classified'},\n  {val: 1, text: 'Information'},\n  {val: 2, text: 'Warning'},\n  {val: 3, text: 'Average'},\n  {val: 4, text: 'High'},\n  {val: 5, text: 'Disaster'}\n];\n\n/** Minimum interval for SLA over time (1 hour) */\nexport const MIN_SLA_INTERVAL = 3600;\n\nexport const RANGE_VARIABLE_VALUE = 'range_series';\n","import { SelectableValue } from \"@grafana/data\";\n\nexport interface VariableQueryProps {\n  query: LegacyVariableQuery;\n  onChange: (query: VariableQuery, definition: string) => void;\n  datasource: any;\n  templateSrv: any;\n}\n\nexport interface VariableQueryData extends VariableQuery {\n  selectedQueryType: SelectableValue<VariableQueryTypes>;\n  legacyQuery?: string;\n}\n\nexport interface VariableQuery {\n  queryType: VariableQueryTypes;\n  group?: string;\n  host?: string;\n  application?: string;\n  item?: string;\n}\n\nexport type LegacyVariableQuery = VariableQuery | string;\n\nexport enum VariableQueryTypes {\n  Group = 'group',\n  Host = 'host',\n  Application = 'application',\n  Item = 'item',\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__8__;","module.exports = __WEBPACK_EXTERNAL_MODULE__10__;","module.exports = __WEBPACK_EXTERNAL_MODULE__11__;","module.exports = __WEBPACK_EXTERNAL_MODULE__12__;","module.exports = __WEBPACK_EXTERNAL_MODULE__13__;","module.exports = __WEBPACK_EXTERNAL_MODULE__14__;","module.exports = __WEBPACK_EXTERNAL_MODULE__17__;","module.exports = __WEBPACK_EXTERNAL_MODULE__18__;","module.exports = __WEBPACK_EXTERNAL_MODULE__21__;","module.exports = __WEBPACK_EXTERNAL_MODULE__22__;","module.exports = __WEBPACK_EXTERNAL_MODULE__23__;","module.exports = __WEBPACK_EXTERNAL_MODULE__25__;","import _ from 'lodash';\n\n/**\n * Query format migration.\n * This module can detect query format version and make migration.\n */\n\nexport function isGrafana2target(target) {\n  if (!target.mode || target.mode === 0 || target.mode === 2) {\n    if ((target.hostFilter || target.itemFilter || target.downsampleFunction ||\n        (target.host && target.host.host)) &&\n        (target.item.filter === undefined && target.host.filter === undefined)) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n\nexport function migrateFrom2To3version(target) {\n  target.group.filter = target.group.name === \"*\" ? \"/.*/\" : target.group.name;\n  target.host.filter = target.host.name === \"*\" ? convertToRegex(target.hostFilter) : target.host.name;\n  target.application.filter = target.application.name === \"*\" ? \"\" : target.application.name;\n  target.item.filter = target.item.name === \"All\" ? convertToRegex(target.itemFilter) : target.item.name;\n  return target;\n}\n\nexport function migrate(target) {\n  target.resultFormat = target.resultFormat || 'time_series';\n  target = fixTargetGroup(target);\n  if (isGrafana2target(target)) {\n    return migrateFrom2To3version(target);\n  }\n  migratePercentileAgg(target);\n  return target;\n}\n\nfunction fixTargetGroup(target) {\n  if (target.group && Array.isArray(target.group)) {\n    target.group = { 'filter': \"\" };\n  }\n  return target;\n}\n\nfunction convertToRegex(str) {\n  if (str) {\n    return '/' + str + '/';\n  } else {\n    return '/.*/';\n  }\n}\n\nfunction migratePercentileAgg(target) {\n  if (target.functions) {\n    for (const f of target.functions) {\n      if (f.def && f.def.name === 'percentil') {\n        f.def.name = 'percentile';\n      }\n    }\n  }\n}\n\nexport const DS_CONFIG_SCHEMA = 2;\nexport function migrateDSConfig(jsonData) {\n  if (!jsonData) {\n    jsonData = {};\n  }\n\n  if (!shouldMigrateDSConfig(jsonData)) {\n    return jsonData;\n  }\n\n  const oldVersion = jsonData.schema || 1;\n  jsonData.schema = DS_CONFIG_SCHEMA;\n\n  if (oldVersion < 2) {\n    const dbConnectionOptions = jsonData.dbConnection || {};\n    jsonData.dbConnectionEnable = dbConnectionOptions.enable || false;\n    jsonData.dbConnectionDatasourceId = dbConnectionOptions.datasourceId || null;\n    delete jsonData.dbConnection;\n  }\n\n  return jsonData;\n}\n\nfunction shouldMigrateDSConfig(jsonData): boolean {\n  if (jsonData.dbConnection && !_.isEmpty(jsonData.dbConnection)) {\n    return true;\n  }\n  if (jsonData.schema && jsonData.schema !== DS_CONFIG_SCHEMA) {\n    return true;\n  }\n  return false;\n}\n","import _ from 'lodash';\nimport $ from 'jquery';\n\nvar index = [];\nvar categories = {\n  Transform: [],\n  Aggregate: [],\n  Filter: [],\n  Trends: [],\n  Time: [],\n  Alias: [],\n  Special: []\n};\n\nfunction addFuncDef(funcDef) {\n  funcDef.params = funcDef.params || [];\n  funcDef.defaultParams = funcDef.defaultParams || [];\n\n  if (funcDef.category) {\n    categories[funcDef.category].push(funcDef);\n  }\n  index[funcDef.name] = funcDef;\n  index[funcDef.shortName || funcDef.name] = funcDef;\n}\n\n// Transform\n\naddFuncDef({\n  name: 'groupBy',\n  category: 'Transform',\n  params: [\n    { name: 'interval', type: 'string'},\n    { name: 'function', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: ['1m', 'avg'],\n});\n\naddFuncDef({\n  name: 'scale',\n  category: 'Transform',\n  params: [\n    { name: 'factor', type: 'float', options: [100, 0.01, 10, -1]}\n  ],\n  defaultParams: [100],\n});\n\naddFuncDef({\n  name: 'offset',\n  category: 'Transform',\n  params: [\n    { name: 'delta', type: 'float', options: [-100, 100]}\n  ],\n  defaultParams: [100],\n});\n\naddFuncDef({\n  name: 'delta',\n  category: 'Transform',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'rate',\n  category: 'Transform',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'movingAverage',\n  category: 'Transform',\n  params: [\n    { name: 'factor', type: 'int', options: [6, 10, 60, 100, 600] }\n  ],\n  defaultParams: [10],\n});\n\naddFuncDef({\n  name: 'exponentialMovingAverage',\n  category: 'Transform',\n  params: [\n    { name: 'smoothing', type: 'float', options: [6, 10, 60, 100, 600] }\n  ],\n  defaultParams: [0.2],\n});\n\naddFuncDef({\n  name: 'percentile',\n  category: 'Transform',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'percent', type: 'float', options: [25, 50, 75, 90, 95, 99, 99.9] }\n  ],\n  defaultParams: ['1m', 95],\n});\n\naddFuncDef({\n  name: 'removeAboveValue',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'},\n  ],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'removeBelowValue',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'},\n  ],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'transformNull',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'}\n  ],\n  defaultParams: [0],\n});\n\n// Aggregate\n\naddFuncDef({\n  name: 'sumSeries',\n  category: 'Aggregate',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'median',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string'}\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'average',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'percentileAgg',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'percent', type: 'float', options: [25, 50, 75, 90, 95, 99, 99.9] }\n  ],\n  defaultParams: ['1m', 95],\n});\n\naddFuncDef({\n  name: 'min',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'max',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'sum',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'count',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'aggregateBy',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'function', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: ['1m', 'avg'],\n});\n\n// Filter\n\naddFuncDef({\n  name: 'top',\n  category: 'Filter',\n  params: [\n    { name: 'number', type: 'int' },\n    { name: 'value', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: [5, 'avg'],\n});\n\naddFuncDef({\n  name: 'bottom',\n  category: 'Filter',\n  params: [\n    { name: 'number', type: 'int' },\n    { name: 'value', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: [5, 'avg'],\n});\n\naddFuncDef({\n  name: 'sortSeries',\n  category: 'Filter',\n  params: [\n    { name: 'direction', type: 'string', options: ['asc', 'desc'] }\n  ],\n  defaultParams: ['asc']\n});\n\n// Trends\n\naddFuncDef({\n  name: 'trendValue',\n  category: 'Trends',\n  params: [\n    { name: 'type', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count'] }\n  ],\n  defaultParams: ['avg'],\n});\n\n// Time\n\naddFuncDef({\n  name: 'timeShift',\n  category: 'Time',\n  params: [\n    { name: 'interval', type: 'string', options: ['24h', '7d', '1M', '+24h', '-24h']}\n  ],\n  defaultParams: ['24h'],\n});\n\n//Alias\n\naddFuncDef({\n  name: 'setAlias',\n  category: 'Alias',\n  params: [\n    { name: 'alias', type: 'string' }\n  ],\n  defaultParams: []\n});\n\naddFuncDef({\n  name: 'setAliasByRegex',\n  category: 'Alias',\n  params: [\n    { name: 'aliasByRegex', type: 'string' }\n  ],\n  defaultParams: []\n});\n\naddFuncDef({\n  name: 'replaceAlias',\n  category: 'Alias',\n  params: [\n    { name: 'regexp', type: 'string' },\n    { name: 'newAlias', type: 'string' }\n  ],\n  defaultParams: ['/(.*)/', '$1']\n});\n\n// Special\naddFuncDef({\n  name: 'consolidateBy',\n  category: 'Special',\n  params: [\n    { name: 'type', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count'] }\n  ],\n  defaultParams: ['avg'],\n});\n\n_.each(categories, function(funcList, catName) {\n  categories[catName] = _.sortBy(funcList, 'name');\n});\n\nclass FuncInstance {\n  constructor(funcDef, params) {\n    this.def = funcDef;\n\n    if (params) {\n      this.params = params;\n    } else {\n      // Create with default params\n      this.params = [];\n      this.params = funcDef.defaultParams.slice(0);\n    }\n\n    this.updateText();\n  }\n\n  bindFunction(metricFunctions) {\n    var func = metricFunctions[this.def.name];\n    if (func) {\n\n      // Bind function arguments\n      var bindedFunc = func;\n      var param;\n      for (var i = 0; i < this.params.length; i++) {\n        param = this.params[i];\n\n        // Convert numeric params\n        if (this.def.params[i].type === 'int' ||\n            this.def.params[i].type === 'float') {\n          param = Number(param);\n        }\n        bindedFunc = _.partial(bindedFunc, param);\n      }\n      return bindedFunc;\n    } else {\n      throw { message: 'Method not found ' + this.def.name };\n    }\n  }\n\n  render(metricExp) {\n    var str = this.def.name + '(';\n    var parameters = _.map(this.params, function(value, index) {\n\n      var paramType = this.def.params[index].type;\n      if (paramType === 'int' ||\n          paramType === 'float' ||\n          paramType === 'value_or_series' ||\n          paramType === 'boolean') {\n        return value;\n      }\n      else if (paramType === 'int_or_interval' && $.isNumeric(value)) {\n        return value;\n      }\n\n      return \"'\" + value + \"'\";\n\n    }, this);\n\n    if (metricExp) {\n      parameters.unshift(metricExp);\n    }\n\n    return str + parameters.join(', ') + ')';\n  }\n\n  _hasMultipleParamsInString(strValue, index) {\n    if (strValue.indexOf(',') === -1) {\n      return false;\n    }\n\n    return this.def.params[index + 1] && this.def.params[index + 1].optional;\n  }\n\n  updateParam(strValue, index) {\n    // handle optional parameters\n    // if string contains ',' and next param is optional, split and update both\n    if (this._hasMultipleParamsInString(strValue, index)) {\n      _.each(strValue.split(','), function(partVal, idx) {\n        this.updateParam(partVal.trim(), idx);\n      }, this);\n      return;\n    }\n\n    if (strValue === '' && this.def.params[index].optional) {\n      this.params.splice(index, 1);\n    }\n    else {\n      this.params[index] = strValue;\n    }\n\n    this.updateText();\n  }\n\n  updateText() {\n    if (this.params.length === 0) {\n      this.text = this.def.name + '()';\n      return;\n    }\n\n    var text = this.def.name + '(';\n    text += this.params.join(', ');\n    text += ')';\n    this.text = text;\n  }\n}\n\nexport function createFuncInstance(funcDef, params) {\n  if (_.isString(funcDef)) {\n    if (!index[funcDef]) {\n      throw { message: 'Method not found ' + name };\n    }\n    funcDef = index[funcDef];\n  }\n  return new FuncInstance(funcDef, params);\n}\n\nexport function getFuncDef(name) {\n  return index[name];\n}\n\nexport function getCategories() {\n  return categories;\n}\n","/**\n * timeseries.js\n *\n * This module contains functions for working with time series.\n *\n * datapoints - array of points where point is [value, timestamp]. In almost all cases (if other wasn't\n * explicitly said) we assume datapoints are sorted by timestamp. Timestamp is the number of milliseconds\n * since 1 January 1970 00:00:00 UTC.\n *\n */\n\nimport _ from 'lodash';\nimport * as utils from './utils';\nimport * as c from './constants';\n\nconst POINT_VALUE = 0;\nconst POINT_TIMESTAMP = 1;\n\n/**\n * Downsample time series by using given function (avg, min, max).\n */\nfunction downsample(datapoints, time_to, ms_interval, func) {\n  var downsampledSeries = [];\n  var timeWindow = {\n    from: time_to * 1000 - ms_interval,\n    to: time_to * 1000\n  };\n\n  var points_sum = 0;\n  var points_num = 0;\n  var value_avg = 0;\n  var frame = [];\n\n  for (var i = datapoints.length - 1; i >= 0; i -= 1) {\n    if (timeWindow.from < datapoints[i][1] && datapoints[i][1] <= timeWindow.to) {\n      points_sum += datapoints[i][0];\n      points_num++;\n      frame.push(datapoints[i][0]);\n    }\n    else {\n      value_avg = points_num ? points_sum / points_num : 0;\n\n      if (func === \"max\") {\n        downsampledSeries.push([_.max(frame), timeWindow.to]);\n      }\n      else if (func === \"min\") {\n        downsampledSeries.push([_.min(frame), timeWindow.to]);\n      }\n\n      // avg by default\n      else {\n        downsampledSeries.push([value_avg, timeWindow.to]);\n      }\n\n      // Shift time window\n      timeWindow.to = timeWindow.from;\n      timeWindow.from -= ms_interval;\n\n      points_sum = 0;\n      points_num = 0;\n      frame = [];\n\n      // Process point again\n      i++;\n    }\n  }\n  return downsampledSeries.reverse();\n}\n\n/**\n * Group points by given time interval\n * datapoints: [[<value>, <unixtime>], ...]\n */\nfunction groupBy(datapoints, interval, groupByCallback) {\n  var ms_interval = utils.parseInterval(interval);\n\n  // Calculate frame timestamps\n  var frames = _.groupBy(datapoints, function (point) {\n    // Calculate time for group of points\n    return Math.floor(point[1] / ms_interval) * ms_interval;\n  });\n\n  // frame: { '<unixtime>': [[<value>, <unixtime>], ...] }\n  // return [{ '<unixtime>': <value> }, { '<unixtime>': <value> }, ...]\n  var grouped = _.mapValues(frames, function (frame) {\n    var points = _.map(frame, function (point) {\n      return point[0];\n    });\n    return groupByCallback(points);\n  });\n\n  // Convert points to Grafana format\n  return sortByTime(_.map(grouped, function (value, timestamp) {\n    return [Number(value), Number(timestamp)];\n  }));\n}\n\nexport function groupBy_perf(datapoints, interval, groupByCallback) {\n  if (datapoints.length === 0) {\n    return [];\n  }\n\n  if (interval === c.RANGE_VARIABLE_VALUE) {\n    return groupByRange(datapoints, groupByCallback);\n  }\n\n  let ms_interval = utils.parseInterval(interval);\n  let grouped_series = [];\n  let frame_values = [];\n  let frame_value;\n  let frame_ts = datapoints.length ? getPointTimeFrame(datapoints[0][POINT_TIMESTAMP], ms_interval) : 0;\n  let point_frame_ts = frame_ts;\n  let point;\n\n  for (let i=0; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_frame_ts = getPointTimeFrame(point[POINT_TIMESTAMP], ms_interval);\n    if (point_frame_ts === frame_ts) {\n      frame_values.push(point[POINT_VALUE]);\n    } else if (point_frame_ts > frame_ts) {\n      frame_value = groupByCallback(frame_values);\n      grouped_series.push([frame_value, frame_ts]);\n\n      // Move frame window to next non-empty interval and fill empty by null\n      frame_ts += ms_interval;\n      while (frame_ts < point_frame_ts) {\n        grouped_series.push([null, frame_ts]);\n        frame_ts += ms_interval;\n      }\n      frame_values = [point[POINT_VALUE]];\n    }\n  }\n\n  frame_value = groupByCallback(frame_values);\n  grouped_series.push([frame_value, frame_ts]);\n\n  return grouped_series;\n}\n\nexport function groupByRange(datapoints, groupByCallback) {\n  const frame_values = [];\n  const frame_start = datapoints[0][POINT_TIMESTAMP];\n  const frame_end = datapoints[datapoints.length - 1][POINT_TIMESTAMP];\n  let point;\n  for (let i=0; i < datapoints.length; i++) {\n    point = datapoints[i];\n    frame_values.push(point[POINT_VALUE]);\n  }\n  const frame_value = groupByCallback(frame_values);\n  return [[frame_value, frame_start], [frame_value, frame_end]];\n}\n\n/**\n * Summarize set of time series into one.\n * @param {datapoints[]} timeseries array of time series\n */\nfunction sumSeries(timeseries) {\n\n  // Calculate new points for interpolation\n  var new_timestamps = _.uniq(_.map(_.flatten(timeseries, true), function (point) {\n    return point[1];\n  }));\n  new_timestamps = _.sortBy(new_timestamps);\n\n  var interpolated_timeseries = _.map(timeseries, function (series) {\n    series = fillZeroes(series, new_timestamps);\n    var timestamps = _.map(series, function (point) {\n      return point[1];\n    });\n    var new_points = _.map(_.difference(new_timestamps, timestamps), function (timestamp) {\n      return [null, timestamp];\n    });\n    var new_series = series.concat(new_points);\n    return sortByTime(new_series);\n  });\n\n  _.each(interpolated_timeseries, interpolateSeries);\n\n  var new_timeseries = [];\n  var sum;\n  for (var i = new_timestamps.length - 1; i >= 0; i--) {\n    sum = 0;\n    for (var j = interpolated_timeseries.length - 1; j >= 0; j--) {\n      sum += interpolated_timeseries[j][i][0];\n    }\n    new_timeseries.push([sum, new_timestamps[i]]);\n  }\n\n  return sortByTime(new_timeseries);\n}\n\nfunction scale(datapoints, factor) {\n  return _.map(datapoints, point => {\n    return [\n      point[0] * factor,\n      point[1]\n    ];\n  });\n}\n\nfunction scale_perf(datapoints, factor) {\n  for (let i = 0; i < datapoints.length; i++) {\n    datapoints[i] = [\n      datapoints[i][POINT_VALUE] * factor,\n      datapoints[i][POINT_TIMESTAMP]\n    ];\n  }\n\n  return datapoints;\n}\n\nfunction offset(datapoints, delta) {\n  for (let i = 0; i < datapoints.length; i++) {\n    datapoints[i] = [\n      datapoints[i][POINT_VALUE] + delta,\n      datapoints[i][POINT_TIMESTAMP]\n    ];\n  }\n\n  return datapoints;\n}\n\n/**\n * Simple delta. Calculate value delta between points.\n * @param {*} datapoints\n */\nfunction delta(datapoints) {\n  let newSeries = [];\n  let deltaValue;\n  for (var i = 1; i < datapoints.length; i++) {\n    deltaValue = datapoints[i][0] - datapoints[i - 1][0];\n    newSeries.push([deltaValue, datapoints[i][1]]);\n  }\n  return newSeries;\n}\n\n/**\n * Calculates rate per second. Resistant to counter reset.\n * @param {*} datapoints\n */\nfunction rate(datapoints) {\n  let newSeries = [];\n  let point, point_prev;\n  let valueDelta = 0;\n  let timeDelta = 0;\n  for (let i = 1; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_prev = datapoints[i - 1];\n\n    // Convert ms to seconds\n    timeDelta = (point[POINT_TIMESTAMP] - point_prev[POINT_TIMESTAMP]) / 1000;\n\n    // Handle counter reset - use previous value\n    if (point[POINT_VALUE] >= point_prev[POINT_VALUE]) {\n      valueDelta = (point[POINT_VALUE] - point_prev[POINT_VALUE]) / timeDelta;\n    }\n\n    newSeries.push([valueDelta, point[POINT_TIMESTAMP]]);\n  }\n  return newSeries;\n}\n\nfunction simpleMovingAverage(datapoints, n) {\n  let sma = [];\n  let w_sum;\n  let w_avg = null;\n  let w_count = 0;\n\n  // Initial window\n  for (let j = n; j > 0; j--) {\n    if (datapoints[n - j][POINT_VALUE] !== null) {\n      w_avg += datapoints[n - j][POINT_VALUE];\n      w_count++;\n    }\n  }\n  if (w_count > 0) {\n    w_avg = w_avg / w_count;\n  } else {\n    w_avg = null;\n  }\n  sma.push([w_avg, datapoints[n - 1][POINT_TIMESTAMP]]);\n\n  for (let i = n; i < datapoints.length; i++) {\n    // Insert next value\n    if (datapoints[i][POINT_VALUE] !== null) {\n      w_sum = w_avg * w_count;\n      w_avg = (w_sum + datapoints[i][POINT_VALUE]) / (w_count + 1);\n      w_count++;\n    }\n    // Remove left side point\n    if (datapoints[i - n][POINT_VALUE] !== null) {\n      w_sum = w_avg * w_count;\n      if (w_count > 1) {\n        w_avg = (w_sum - datapoints[i - n][POINT_VALUE]) / (w_count - 1);\n        w_count--;\n      } else {\n        w_avg = null;\n        w_count = 0;\n      }\n    }\n    sma.push([w_avg, datapoints[i][POINT_TIMESTAMP]]);\n  }\n  return sma;\n}\n\nfunction expMovingAverage(datapoints, n) {\n  let ema = [datapoints[0]];\n  let ema_prev = datapoints[0][POINT_VALUE];\n  let ema_cur;\n  let a;\n\n  if (n > 1) {\n    // Calculate a from window size\n    a = 2 / (n + 1);\n\n    // Initial window, use simple moving average\n    let w_avg = null;\n    let w_count = 0;\n    for (let j = n; j > 0; j--) {\n      if (datapoints[n - j][POINT_VALUE] !== null) {\n        w_avg += datapoints[n - j][POINT_VALUE];\n        w_count++;\n      }\n    }\n    if (w_count > 0) {\n      w_avg = w_avg / w_count;\n      // Actually, we should set timestamp from datapoints[n-1] and start calculation of EMA from n.\n      // But in order to start EMA from first point (not from Nth) we should expand time range and request N additional\n      // points outside left side of range. We can't do that, so this trick is used for pretty view of first N points.\n      // We calculate AVG for first N points, but then start from 2nd point, not from Nth. In general, it means we\n      // assume that previous N values (0-N, 0-(N-1), ..., 0-1) have the same average value as a first N values.\n      ema = [[w_avg, datapoints[0][POINT_TIMESTAMP]]];\n      ema_prev = w_avg;\n      n = 1;\n    }\n  } else {\n    // Use predefined a and start from 1st point (use it as initial EMA value)\n    a = n;\n    n = 1;\n  }\n\n  for (let i = n; i < datapoints.length; i++) {\n    if (datapoints[i][POINT_VALUE] !== null) {\n      ema_cur = a * datapoints[i][POINT_VALUE] + (1 - a) * ema_prev;\n      ema_prev = ema_cur;\n      ema.push([ema_cur, datapoints[i][POINT_TIMESTAMP]]);\n    } else {\n      ema.push([null, datapoints[i][POINT_TIMESTAMP]]);\n    }\n  }\n  return ema;\n}\n\nfunction PERCENTILE(n, values) {\n  var sorted = _.sortBy(values);\n  return sorted[Math.floor(sorted.length * n / 100)];\n}\n\nfunction COUNT(values) {\n  return values.length;\n}\n\nfunction SUM(values) {\n  var sum = null;\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      sum += values[i];\n    }\n  }\n  return sum;\n}\n\nfunction AVERAGE(values) {\n  let values_non_null = getNonNullValues(values);\n  if (values_non_null.length === 0) {\n    return null;\n  }\n  return SUM(values_non_null) / values_non_null.length;\n}\n\nfunction getNonNullValues(values) {\n  let values_non_null = [];\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      values_non_null.push(values[i]);\n    }\n  }\n  return values_non_null;\n}\n\nfunction MIN(values) {\n  return _.min(values);\n}\n\nfunction MAX(values) {\n  return _.max(values);\n}\n\nfunction MEDIAN(values) {\n  var sorted = _.sortBy(values);\n  return sorted[Math.floor(sorted.length / 2)];\n}\n\n///////////////////////\n// Utility functions //\n///////////////////////\n\n/**\n * For given point calculate corresponding time frame.\n *\n * |__*_|_*__|___*| -> |*___|*___|*___|\n *\n * @param {*} timestamp\n * @param {*} ms_interval\n */\nfunction getPointTimeFrame(timestamp, ms_interval) {\n  return Math.floor(timestamp / ms_interval) * ms_interval;\n}\n\nfunction sortByTime(series) {\n  return _.sortBy(series, function (point) {\n    return point[1];\n  });\n}\n\n/**\n * Fill empty front and end of series by zeroes.\n *\n * |   ***   |    |   ***   |\n * |___   ___| -> |***   ***|\n * @param {*} series\n * @param {*} timestamps\n */\nfunction fillZeroes(series, timestamps) {\n  let prepend = [];\n  let append = [];\n  let new_point;\n  for (let i = 0; i < timestamps.length; i++) {\n    if (timestamps[i] < series[0][POINT_TIMESTAMP]) {\n      new_point = [0, timestamps[i]];\n      prepend.push(new_point);\n    } else if (timestamps[i] > series[series.length - 1][POINT_TIMESTAMP]) {\n      new_point = [0, timestamps[i]];\n      append.push(new_point);\n    }\n  }\n  return _.concat(_.concat(prepend, series), append);\n}\n\n/**\n * Interpolate series with gaps\n */\nfunction interpolateSeries(series) {\n  var left, right;\n\n  // Interpolate series\n  for (var i = series.length - 1; i >= 0; i--) {\n    if (!series[i][0]) {\n      left = findNearestLeft(series, i);\n      right = findNearestRight(series, i);\n      if (!left) {\n        left = right;\n      }\n      if (!right) {\n        right = left;\n      }\n      series[i][0] = linearInterpolation(series[i][1], left, right);\n    }\n  }\n  return series;\n}\n\nfunction linearInterpolation(timestamp, left, right) {\n  if (left[1] === right[1]) {\n    return (left[0] + right[0]) / 2;\n  } else {\n    return (left[0] + (right[0] - left[0]) / (right[1] - left[1]) * (timestamp - left[1]));\n  }\n}\n\nfunction findNearestRight(series, pointIndex) {\n  for (var i = pointIndex; i < series.length; i++) {\n    if (series[i][0] !== null) {\n      return series[i];\n    }\n  }\n  return null;\n}\n\nfunction findNearestLeft(series, pointIndex) {\n  for (var i = pointIndex; i > 0; i--) {\n    if (series[i][0] !== null) {\n      return series[i];\n    }\n  }\n  return null;\n}\n\nfunction flattenDatapoints(datapoints) {\n  const depth = utils.getArrayDepth(datapoints);\n  if (depth <= 2) {\n    // Don't process if datapoints already flattened\n    return datapoints;\n  }\n  return _.flatten(datapoints);\n}\n\n////////////\n// Export //\n////////////\n\nconst exportedFunctions = {\n  downsample,\n  groupBy,\n  groupBy_perf,\n  groupByRange,\n  sumSeries,\n  scale,\n  offset,\n  scale_perf,\n  delta,\n  rate,\n  simpleMovingAverage,\n  expMovingAverage,\n  SUM,\n  COUNT,\n  AVERAGE,\n  MIN,\n  MAX,\n  MEDIAN,\n  PERCENTILE,\n  sortByTime,\n  flattenDatapoints,\n};\n\nexport default exportedFunctions;\n","import _ from 'lodash';\nimport * as utils from './utils';\nimport ts, { groupBy_perf as groupBy } from './timeseries';\n\nlet SUM = ts.SUM;\nlet COUNT = ts.COUNT;\nlet AVERAGE = ts.AVERAGE;\nlet MIN = ts.MIN;\nlet MAX = ts.MAX;\nlet MEDIAN = ts.MEDIAN;\nlet PERCENTILE = ts.PERCENTILE;\n\nlet downsampleSeries = ts.downsample;\nlet groupBy_exported = (interval, groupFunc, datapoints) => groupBy(datapoints, interval, groupFunc);\nlet sumSeries = ts.sumSeries;\nlet delta = ts.delta;\nlet rate = ts.rate;\nlet scale = (factor, datapoints) => ts.scale_perf(datapoints, factor);\nlet offset = (delta, datapoints) => ts.offset(datapoints, delta);\nlet simpleMovingAverage = (n, datapoints) => ts.simpleMovingAverage(datapoints, n);\nlet expMovingAverage = (a, datapoints) => ts.expMovingAverage(datapoints, a);\nlet percentile = (interval, n, datapoints) => groupBy(datapoints, interval, _.partial(PERCENTILE, n));\n\nfunction limit(order, n, orderByFunc, timeseries) {\n  let orderByCallback = aggregationFunctions[orderByFunc];\n  let sortByIteratee = (ts) => {\n    let values = _.map(ts.datapoints, (point) => {\n      return point[0];\n    });\n    return orderByCallback(values);\n  };\n  let sortedTimeseries = _.sortBy(timeseries, sortByIteratee);\n  if (order === 'bottom') {\n    return sortedTimeseries.slice(0, n);\n  } else {\n    return sortedTimeseries.slice(-n);\n  }\n}\n\nfunction removeAboveValue(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] > n) ? null : point[0],\n      point[1]\n    ];\n  });\n}\n\nfunction removeBelowValue(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] < n) ? null : point[0],\n      point[1]\n    ];\n  });\n}\n\nfunction transformNull(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] !== null) ? point[0] : n,\n      point[1]\n    ];\n  });\n}\n\nfunction sortSeries(direction, timeseries) {\n  return _.orderBy(timeseries, [function (ts) {\n    return ts.target.toLowerCase();\n  }], direction);\n}\n\nfunction setAlias(alias, timeseries) {\n  timeseries.target = alias;\n  return timeseries;\n}\n\nfunction replaceAlias(regexp, newAlias, timeseries) {\n  let pattern;\n  if (utils.isRegex(regexp)) {\n    pattern = utils.buildRegex(regexp);\n  } else {\n    pattern = regexp;\n  }\n\n  let alias = timeseries.target.replace(pattern, newAlias);\n  timeseries.target = alias;\n  return timeseries;\n}\n\nfunction setAliasByRegex(alias, timeseries) {\n  timeseries.target = extractText(timeseries.target, alias);\n  return timeseries;\n}\n\nfunction extractText(str, pattern) {\n  var extractPattern = new RegExp(pattern);\n  var extractedValue = extractPattern.exec(str);\n  extractedValue = extractedValue[0];\n  return extractedValue;\n}\n\nfunction groupByWrapper(interval, groupFunc, datapoints) {\n  var groupByCallback = aggregationFunctions[groupFunc];\n  return groupBy(datapoints, interval, groupByCallback);\n}\n\nfunction aggregateByWrapper(interval, aggregateFunc, datapoints) {\n  // Flatten all points in frame and then just use groupBy()\n  const flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  let groupByCallback = aggregationFunctions[aggregateFunc];\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction aggregateWrapper(groupByCallback, interval, datapoints) {\n  var flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction percentileAgg(interval, n, datapoints) {\n  const flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  let groupByCallback = _.partial(PERCENTILE, n);\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction timeShift(interval, range) {\n  let shift = utils.parseTimeShiftInterval(interval) / 1000;\n  return _.map(range, time => {\n    return time - shift;\n  });\n}\n\nfunction unShiftTimeSeries(interval, datapoints) {\n  let unshift = utils.parseTimeShiftInterval(interval);\n  return _.map(datapoints, dp => {\n    return [\n      dp[0],\n      dp[1] + unshift\n    ];\n  });\n}\n\nlet metricFunctions = {\n  groupBy: groupByWrapper,\n  scale: scale,\n  offset: offset,\n  delta: delta,\n  rate: rate,\n  movingAverage: simpleMovingAverage,\n  exponentialMovingAverage: expMovingAverage,\n  percentile: percentile,\n  transformNull: transformNull,\n  aggregateBy: aggregateByWrapper,\n  // Predefined aggs\n  percentileAgg: percentileAgg,\n  average: _.partial(aggregateWrapper, AVERAGE),\n  min: _.partial(aggregateWrapper, MIN),\n  max: _.partial(aggregateWrapper, MAX),\n  median: _.partial(aggregateWrapper, MEDIAN),\n  sum: _.partial(aggregateWrapper, SUM),\n  count: _.partial(aggregateWrapper, COUNT),\n  sumSeries: sumSeries,\n  removeAboveValue: removeAboveValue,\n  removeBelowValue: removeBelowValue,\n  top: _.partial(limit, 'top'),\n  bottom: _.partial(limit, 'bottom'),\n  sortSeries: sortSeries,\n  timeShift: timeShift,\n  setAlias: setAlias,\n  setAliasByRegex: setAliasByRegex,\n  replaceAlias: replaceAlias\n};\n\nlet aggregationFunctions = {\n  avg: AVERAGE,\n  min: MIN,\n  max: MAX,\n  median: MEDIAN,\n  sum: SUM,\n  count: COUNT\n};\n\nexport default {\n  downsampleSeries: downsampleSeries,\n  groupBy: groupBy_exported,\n  AVERAGE: AVERAGE,\n  MIN: MIN,\n  MAX: MAX,\n  MEDIAN: MEDIAN,\n  SUM: SUM,\n  COUNT: COUNT,\n  unShiftTimeSeries: unShiftTimeSeries,\n\n  get aggregationFunctions() {\n    return aggregationFunctions;\n  },\n\n  get metricFunctions() {\n    return metricFunctions;\n  }\n};\n","import _ from 'lodash';\nimport TableModel from 'grafana/app/core/table_model';\nimport * as c from './constants';\n\n/**\n * Convert Zabbix API history.get response to Grafana format\n *\n * @return {Array}            Array of timeseries in Grafana format\n *                            {\n *                               target: \"Metric name\",\n *                               datapoints: [[<value>, <unixtime>], ...]\n *                            }\n */\nfunction convertHistory(history, items, addHostName, convertPointCallback) {\n  /**\n   * Response should be in the format:\n   * data: [\n   *          {\n   *             target: \"Metric name\",\n   *             datapoints: [[<value>, <unixtime>], ...]\n   *          }, ...\n   *       ]\n   */\n\n  // Group history by itemid\n  var grouped_history = _.groupBy(history, 'itemid');\n  var hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid');  //uniqBy is needed to deduplicate\n\n  return _.map(grouped_history, function(hist, itemid) {\n    var item = _.find(items, {'itemid': itemid});\n    var alias = item.name;\n    if (_.keys(hosts).length > 1 && addHostName) {   //only when actual multi hosts selected\n      var host = _.find(hosts, {'hostid': item.hostid});\n      alias = host.name + \": \" + alias;\n    }\n    return {\n      target: alias,\n      datapoints: _.map(hist, convertPointCallback)\n    };\n  });\n}\n\nfunction sortTimeseries(timeseries) {\n  // Sort trend data, issue #202\n  _.forEach(timeseries, series => {\n    series.datapoints = _.sortBy(series.datapoints, point => point[c.DATAPOINT_TS]);\n  });\n  return timeseries;\n}\n\nfunction handleHistory(history, items, addHostName = true) {\n  return convertHistory(history, items, addHostName, convertHistoryPoint);\n}\n\nfunction handleTrends(history, items, valueType, addHostName = true) {\n  var convertPointCallback = _.partial(convertTrendPoint, valueType);\n  return convertHistory(history, items, addHostName, convertPointCallback);\n}\n\nfunction handleText(history, items, target, addHostName = true) {\n  let convertTextCallback = _.partial(convertText, target);\n  return convertHistory(history, items, addHostName, convertTextCallback);\n}\n\nfunction handleHistoryAsTable(history, items, target) {\n  let table = new TableModel();\n  table.addColumn({text: 'Host'});\n  table.addColumn({text: 'Item'});\n  table.addColumn({text: 'Key'});\n  table.addColumn({text: 'Last value'});\n\n  let grouped_history = _.groupBy(history, 'itemid');\n  _.each(items, (item) => {\n    let itemHistory = grouped_history[item.itemid] || [];\n    let lastPoint = _.last(itemHistory);\n    let lastValue = lastPoint ? lastPoint.value : null;\n\n    if(target.options.skipEmptyValues && (!lastValue || lastValue === '')) {\n      return;\n    }\n\n    // Regex-based extractor\n    if (target.textFilter) {\n      lastValue = extractText(lastValue, target.textFilter, target.useCaptureGroups);\n    }\n\n    let host = _.first(item.hosts);\n    host = host ? host.name : \"\";\n\n    table.rows.push([\n      host, item.name, item.key_, lastValue\n    ]);\n  });\n\n  return table;\n}\n\nfunction convertText(target, point) {\n  let value = point.value;\n\n  // Regex-based extractor\n  if (target.textFilter) {\n    value = extractText(point.value, target.textFilter, target.useCaptureGroups);\n  }\n\n  return [\n    value,\n    point.clock * 1000 + Math.round(point.ns / 1000000)\n  ];\n}\n\nfunction extractText(str, pattern, useCaptureGroups) {\n  let extractPattern = new RegExp(pattern);\n  let extractedValue = extractPattern.exec(str);\n  if (extractedValue) {\n    if (useCaptureGroups) {\n      extractedValue = extractedValue[1];\n    } else {\n      extractedValue = extractedValue[0];\n    }\n  }\n  return extractedValue;\n}\n\nfunction handleSLAResponse(itservice, slaProperty, slaObject) {\n  var targetSLA = slaObject[itservice.serviceid].sla;\n  if (slaProperty.property === 'status') {\n    var targetStatus = parseInt(slaObject[itservice.serviceid].status);\n    return {\n      target: itservice.name + ' ' + slaProperty.name,\n      datapoints: [\n        [targetStatus, targetSLA[0].to * 1000]\n      ]\n    };\n  } else {\n    let i;\n    let slaArr = [];\n    for (i = 0; i < targetSLA.length; i++) {\n      if (i === 0) {\n        slaArr.push([targetSLA[i][slaProperty.property], targetSLA[i].from * 1000]);\n      }\n      slaArr.push([targetSLA[i][slaProperty.property], targetSLA[i].to * 1000]);\n    }\n    return {\n      target: itservice.name + ' ' + slaProperty.name,\n      datapoints: slaArr\n    };\n  }\n}\n\nfunction handleTriggersResponse(triggers, groups, timeRange) {\n  if (!_.isArray(triggers)) {\n    let triggersCount = null;\n    try {\n      triggersCount = Number(triggers);\n    } catch (err) {\n      console.log(\"Error when handling triggers count: \", err);\n    }\n    return {\n      target: \"triggers count\",\n      datapoints: [\n        [triggersCount, timeRange[1] * 1000]\n      ]\n    };\n  } else {\n    const stats = getTriggerStats(triggers);\n    const groupNames = _.map(groups, 'name');\n    let table = new TableModel();\n    table.addColumn({text: 'Host group'});\n    _.each(_.orderBy(c.TRIGGER_SEVERITY, ['val'], ['desc']), (severity) => {\n      table.addColumn({text: severity.text});\n    });\n    _.each(stats, (severity_stats, group) => {\n      if (_.includes(groupNames, group)) {\n        let row = _.map(_.orderBy(_.toPairs(severity_stats), (s) => s[0], ['desc']), (s) => s[1]);\n        row = _.concat([group], ...row);\n        table.rows.push(row);\n      }\n    });\n    return table;\n  }\n}\n\nfunction getTriggerStats(triggers) {\n  let groups = _.uniq(_.flattenDeep(_.map(triggers, (trigger) => _.map(trigger.groups, 'name'))));\n  // let severity = _.map(c.TRIGGER_SEVERITY, 'text');\n  let stats = {};\n  _.each(groups, (group) => {\n    stats[group] = {0:0, 1:0, 2:0, 3:0, 4:0, 5:0}; // severity:count\n  });\n  _.each(triggers, (trigger) => {\n    _.each(trigger.groups, (group) => {\n      stats[group.name][trigger.priority]++;\n    });\n  });\n  return stats;\n}\n\nfunction convertHistoryPoint(point) {\n  // Value must be a number for properly work\n  return [\n    Number(point.value),\n    point.clock * 1000 + Math.round(point.ns / 1000000)\n  ];\n}\n\nfunction convertTrendPoint(valueType, point) {\n  var value;\n  switch (valueType) {\n    case \"min\":\n      value = point.value_min;\n      break;\n    case \"max\":\n      value = point.value_max;\n      break;\n    case \"avg\":\n      value = point.value_avg;\n      break;\n    case \"sum\":\n      value = point.value_sum;\n      break;\n    case \"count\":\n      value = point.value_count;\n      break;\n    default:\n      value = point.value_avg;\n  }\n\n  return [\n    Number(value),\n    point.clock * 1000\n  ];\n}\n\nexport default {\n  handleHistory,\n  convertHistory,\n  handleTrends,\n  handleText,\n  handleHistoryAsTable,\n  handleSLAResponse,\n  handleTriggersResponse,\n  sortTimeseries\n};\n\n// Fix for backward compatibility with lodash 2.4\nif (!_.uniqBy) {_.uniqBy = _.uniq;}\n","/**\n * This module allows to deduplicate function calls with the same params and\n * cache result of function call.\n */\n\nexport class CachingProxy {\n\n  constructor(cacheOptions) {\n    this.cacheEnabled = cacheOptions.enabled;\n    this.ttl          = cacheOptions.ttl || 600000; // 10 minutes by default\n\n    // Internal objects for data storing\n    this.cache = {};\n    this.promises = {};\n  }\n\n  /**\n   * Check that result is present in the cache and is up to date or send request otherwise.\n   */\n  cacheRequest(func, funcName, funcScope) {\n    return cacheRequest(func, funcName, funcScope, this);\n  }\n\n  /**\n   * Wrap request to prevent multiple calls with same params when request is waiting for response.\n   */\n  proxyfy(func, funcName, funcScope) {\n    if (!this.promises[funcName]) {\n      this.promises[funcName] = {};\n    }\n    const promiseKeeper = this.promises[funcName];\n    return callOnce(func, promiseKeeper, funcScope);\n  }\n\n  proxyfyWithCache(func, funcName, funcScope) {\n    let proxyfied = this.proxyfy(func, funcName, funcScope);\n    return this.cacheRequest(proxyfied, funcName, funcScope);\n  }\n\n  _isExpired(cacheObject) {\n    if (cacheObject) {\n      let object_age = Date.now() - cacheObject.timestamp;\n      return !(cacheObject.timestamp && object_age < this.ttl);\n    } else {\n      return true;\n    }\n  }\n}\n\n/**\n * Wrap request to prevent multiple calls\n * with same params when waiting for result.\n */\nfunction callOnce(func, promiseKeeper, funcScope) {\n  return function() {\n    var hash = getRequestHash(arguments);\n    if (!promiseKeeper[hash]) {\n      promiseKeeper[hash] = Promise.resolve(\n        func.apply(funcScope, arguments)\n        .then(result => {\n          promiseKeeper[hash] = null;\n          return result;\n        })\n      );\n    }\n    return promiseKeeper[hash];\n  };\n}\n\nfunction cacheRequest(func, funcName, funcScope, self) {\n  return function() {\n    if (!self.cache[funcName]) {\n      self.cache[funcName] = {};\n    }\n\n    let cacheObject = self.cache[funcName];\n    let hash = getRequestHash(arguments);\n    if (self.cacheEnabled && !self._isExpired(cacheObject[hash])) {\n      return Promise.resolve(cacheObject[hash].value);\n    } else {\n      return func.apply(funcScope, arguments)\n      .then(result => {\n        cacheObject[hash] = {\n          value: result,\n          timestamp: Date.now()\n        };\n        return result;\n      });\n    }\n  };\n}\n\nfunction getRequestHash(args) {\n  const argsJson = JSON.stringify(args);\n  return argsJson.getHash();\n}\n\nString.prototype.getHash = function() {\n  var hash = 0, i, chr, len;\n  if (this.length !== 0) {\n    for (i = 0, len = this.length; i < len; i++) {\n      chr   = this.charCodeAt(i);\n      hash  = ((hash << 5) - hash) + chr;\n      hash |= 0; // Convert to 32bit integer\n    }\n  }\n  return hash;\n};\n","import _ from 'lodash';\nimport { getDataSourceSrv } from '@grafana/runtime';\n\nexport const DEFAULT_QUERY_LIMIT = 10000;\nexport const HISTORY_TO_TABLE_MAP = {\n  '0': 'history',\n  '1': 'history_str',\n  '2': 'history_log',\n  '3': 'history_uint',\n  '4': 'history_text'\n};\n\nexport const TREND_TO_TABLE_MAP = {\n  '0': 'trends',\n  '3': 'trends_uint'\n};\n\nexport const consolidateByFunc = {\n  'avg': 'AVG',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\nexport const consolidateByTrendColumns = {\n  'avg': 'value_avg',\n  'min': 'value_min',\n  'max': 'value_max',\n  'sum': 'num*value_avg' // sum of sums inside the one-hour trend period\n};\n\n/**\n * Base class for external history database connectors. Subclasses should implement `getHistory()`, `getTrends()` and\n * `testDataSource()` methods, which describe how to fetch data from source other than Zabbix API.\n */\nexport class DBConnector {\n  constructor(options) {\n    this.datasourceId = options.datasourceId;\n    this.datasourceName = options.datasourceName;\n    this.datasourceTypeId = null;\n    this.datasourceTypeName = null;\n  }\n\n  static loadDatasource(dsId, dsName) {\n    if (!dsName && dsId !== undefined) {\n      let ds = _.find(getDataSourceSrv().getAll(), {'id': dsId});\n      if (!ds) {\n        return Promise.reject(`Data Source with ID ${dsId} not found`);\n      }\n      dsName = ds.name;\n    }\n    if (dsName) {\n      return getDataSourceSrv().loadDatasource(dsName);\n    } else {\n      return Promise.reject(`Data Source name should be specified`);\n    }\n  }\n\n  loadDBDataSource() {\n    return DBConnector.loadDatasource(this.datasourceId, this.datasourceName)\n    .then(ds => {\n      this.datasourceTypeId = ds.meta.id;\n      this.datasourceTypeName = ds.meta.name;\n      if (!this.datasourceName) {\n        this.datasourceName = ds.name;\n      }\n      if (!this.datasourceId) {\n        this.datasourceId = ds.id;\n      }\n      return ds;\n    });\n  }\n\n  /**\n   * Send test request to datasource in order to ensure it's working.\n   */\n  testDataSource() {\n    throw new ZabbixNotImplemented('testDataSource()');\n  }\n\n  /**\n   * Get history data from external sources.\n   */\n  getHistory() {\n    throw new ZabbixNotImplemented('getHistory()');\n  }\n\n  /**\n   * Get trends data from external sources.\n   */\n  getTrends() {\n    throw new ZabbixNotImplemented('getTrends()');\n  }\n\n  handleGrafanaTSResponse(history, items, addHostName = true) {\n    return convertGrafanaTSResponse(history, items, addHostName);\n  }\n}\n\n// Define Zabbix DB Connector exception type for non-implemented methods\nexport class ZabbixNotImplemented {\n  constructor(methodName) {\n    this.code = null;\n    this.name = 'ZabbixNotImplemented';\n    this.message = `Zabbix DB Connector Error: method ${methodName || ''} should be implemented in subclass of DBConnector`;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n\n/**\n * Converts time series returned by the data source into format that Grafana expects\n * time_series is Array of series:\n * ```\n * [{\n *     name: string,\n *     points: Array<[value: number, timestamp: number]>\n * }]\n * ```\n */\nfunction convertGrafanaTSResponse(time_series, items, addHostName) {\n  //uniqBy is needed to deduplicate\n  var hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid');\n  let grafanaSeries = _.map(_.compact(time_series), series => {\n    let itemid = series.name;\n    var item = _.find(items, {'itemid': itemid});\n    var alias = item.name;\n    //only when actual multi hosts selected\n    if (_.keys(hosts).length > 1 && addHostName) {\n      var host = _.find(hosts, {'hostid': item.hostid});\n      alias = host.name + \": \" + alias;\n    }\n    // CachingProxy deduplicates requests and returns one time series for equal queries.\n    // Clone is needed to prevent changing of series object shared between all targets.\n    let datapoints = _.cloneDeep(series.points);\n    return {\n      target: alias,\n      datapoints: datapoints\n    };\n  });\n\n  return _.sortBy(grafanaSeries, 'target');\n}\n\nconst defaults = {\n  DBConnector,\n  DEFAULT_QUERY_LIMIT,\n  HISTORY_TO_TABLE_MAP,\n  TREND_TO_TABLE_MAP,\n  consolidateByFunc,\n  consolidateByTrendColumns\n};\n\nexport default defaults;\n","/**\n * General Zabbix API methods\n */\nimport { getBackendSrv } from '@grafana/runtime';\n\nexport class ZabbixAPICore {\n\n  /** @ngInject */\n  constructor() {\n  }\n\n  /**\n   * Request data from Zabbix API\n   * @return {object}  response.result\n   */\n  request(api_url, method, params, options, auth) {\n    let requestData = {\n      jsonrpc: '2.0',\n      method: method,\n      params: params,\n      id: 1\n    };\n\n    if (auth === \"\") {\n      // Reject immediately if not authenticated\n      return Promise.reject(new ZabbixAPIError({data: \"Not authorised.\"}));\n    } else if (auth) {\n      // Set auth parameter only if it needed\n      requestData.auth = auth;\n    }\n\n    let requestOptions = {\n      method: 'POST',\n      url: api_url,\n      data: requestData,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    };\n\n    // Set request options for basic auth\n    if (options.basicAuth || options.withCredentials) {\n      requestOptions.withCredentials = true;\n    }\n    if (options.basicAuth) {\n      requestOptions.headers.Authorization = options.basicAuth;\n    }\n\n    return this.datasourceRequest(requestOptions);\n  }\n\n  datasourceRequest(requestOptions) {\n    return getBackendSrv().datasourceRequest(requestOptions)\n    .then((response) => {\n      if (!response.data) {\n        return Promise.reject(new ZabbixAPIError({data: \"General Error, no data\"}));\n      } else if (response.data.error) {\n\n        // Handle Zabbix API errors\n        return Promise.reject(new ZabbixAPIError(response.data.error));\n      }\n\n      // Success\n      return response.data.result;\n    });\n  }\n\n  /**\n   * Get authentication token.\n   * @return {string}  auth token\n   */\n  login(api_url, username, password, options) {\n    let params = {\n      user: username,\n      password: password\n    };\n    return this.request(api_url, 'user.login', params, options, null);\n  }\n\n  /**\n   * Get Zabbix API version\n   * Matches the version of Zabbix starting from Zabbix 2.0.4\n   */\n  getVersion(api_url, options) {\n    return this.request(api_url, 'apiinfo.version', [], options);\n  }\n}\n\n// Define zabbix API exception type\nexport class ZabbixAPIError {\n  constructor(error) {\n    this.code = error.code || null;\n    this.name = error.message || \"\";\n    this.data = error.data || \"\";\n    this.message = \"Zabbix API Error: \" + this.name + \" \" + this.data;\n  }\n\n  toString() {\n    return this.name + \" \" + this.data;\n  }\n}\n","import _ from 'lodash';\nimport kbn from 'grafana/app/core/utils/kbn';\nimport * as utils from '../../../utils';\nimport { ZabbixAPICore } from './zabbixAPICore';\nimport { ZBX_ACK_ACTION_NONE, ZBX_ACK_ACTION_ACK, ZBX_ACK_ACTION_ADD_MESSAGE, MIN_SLA_INTERVAL } from '../../../constants';\n\n/**\n * Zabbix API Wrapper.\n * Creates Zabbix API instance with given parameters (url, credentials and other).\n * Wraps API calls and provides high-level methods.\n */\nexport class ZabbixAPIConnector {\n  constructor(api_url, username, password, version, basicAuth, withCredentials) {\n    this.url              = api_url;\n    this.username         = username;\n    this.password         = password;\n    this.auth             = '';\n    this.version          = version;\n\n    this.requestOptions = {\n      basicAuth: basicAuth,\n      withCredentials: withCredentials\n    };\n\n    this.loginPromise = null;\n    this.loginErrorCount = 0;\n    this.maxLoginAttempts = 3;\n\n    this.zabbixAPICore = new ZabbixAPICore();\n\n    this.getTrend = this.getTrend_ZBXNEXT1193;\n    //getTrend = getTrend_30;\n  }\n\n  //////////////////////////\n  // Core method wrappers //\n  //////////////////////////\n\n  request(method, params) {\n    return this.zabbixAPICore.request(this.url, method, params, this.requestOptions, this.auth)\n    .catch(error => {\n      if (isNotAuthorized(error.data)) {\n        // Handle auth errors\n        this.loginErrorCount++;\n        if (this.loginErrorCount > this.maxLoginAttempts) {\n          this.loginErrorCount = 0;\n          return null;\n        } else {\n          return this.loginOnce()\n          .then(() => this.request(method, params));\n        }\n      } else {\n        return Promise.reject(error);\n      }\n    });\n  }\n\n  /**\n   * When API unauthenticated or auth token expired each request produce login()\n   * call. But auth token is common to all requests. This function wraps login() method\n   * and call it once. If login() already called just wait for it (return its promise).\n   * @return login promise\n   */\n  loginOnce() {\n    if (!this.loginPromise) {\n      this.loginPromise = Promise.resolve(\n        this.login().then(auth => {\n          this.auth = auth;\n          this.loginPromise = null;\n          return auth;\n        })\n      );\n    }\n    return this.loginPromise;\n  }\n\n  /**\n   * Get authentication token.\n   */\n  login() {\n    return this.zabbixAPICore.login(this.url, this.username, this.password, this.requestOptions);\n  }\n\n  /**\n   * Get Zabbix API version\n   */\n  getVersion() {\n    return this.zabbixAPICore.getVersion(this.url, this.requestOptions);\n  }\n\n  ////////////////////////////////\n  // Zabbix API method wrappers //\n  ////////////////////////////////\n\n  acknowledgeEvent(eventid, message) {\n    const action = this.version >= 4 ? ZBX_ACK_ACTION_ACK + ZBX_ACK_ACTION_ADD_MESSAGE : ZBX_ACK_ACTION_NONE;\n    const params = {\n      eventids: eventid,\n      message: message,\n      action: action\n    };\n\n    return this.request('event.acknowledge', params);\n  }\n\n  getGroups() {\n    var params = {\n      output: ['name'],\n      sortfield: 'name',\n      real_hosts: true\n    };\n\n    return this.request('hostgroup.get', params);\n  }\n\n  getHosts(groupids) {\n    var params = {\n      output: ['name', 'host'],\n      sortfield: 'name'\n    };\n    if (groupids) {\n      params.groupids = groupids;\n    }\n\n    return this.request('host.get', params);\n  }\n\n  getApps(hostids) {\n    var params = {\n      output: 'extend',\n      hostids: hostids\n    };\n\n    return this.request('application.get', params);\n  }\n\n  /**\n   * Get Zabbix items\n   * @param  {[type]} hostids  host ids\n   * @param  {[type]} appids   application ids\n   * @param  {String} itemtype 'num' or 'text'\n   * @return {[type]}          array of items\n   */\n  getItems(hostids, appids, itemtype) {\n    var params = {\n      output: [\n        'name', 'key_',\n        'value_type',\n        'hostid',\n        'status',\n        'state'\n      ],\n      sortfield: 'name',\n      webitems: true,\n      filter: {},\n      selectHosts: ['hostid', 'name']\n    };\n    if (hostids) {\n      params.hostids = hostids;\n    }\n    if (appids) {\n      params.applicationids = appids;\n    }\n    if (itemtype === 'num') {\n      // Return only numeric metrics\n      params.filter.value_type = [0, 3];\n    }\n    if (itemtype === 'text') {\n      // Return only text metrics\n      params.filter.value_type = [1, 2, 4];\n    }\n\n    return this.request('item.get', params)\n    .then(utils.expandItems);\n  }\n\n  getItemsByIDs(itemids) {\n    var params = {\n      itemids: itemids,\n      output: [\n        'name', 'key_',\n        'value_type',\n        'hostid',\n        'status',\n        'state'\n      ],\n      webitems: true,\n      selectHosts: ['hostid', 'name']\n    };\n\n    return this.request('item.get', params)\n    .then(utils.expandItems);\n  }\n\n  getMacros(hostids) {\n    var params = {\n      output: 'extend',\n      hostids: hostids\n    };\n\n    return this.request('usermacro.get', params);\n  }\n\n  getGlobalMacros() {\n    var params = {\n      output: 'extend',\n      globalmacro: true\n    };\n\n    return this.request('usermacro.get', params);\n  }\n\n  getLastValue(itemid) {\n    var params = {\n      output: ['lastvalue'],\n      itemids: itemid\n    };\n    return this.request('item.get', params)\n    .then(items => items.length ? items[0].lastvalue : null);\n  }\n\n  /**\n   * Perform history query from Zabbix API\n   *\n   * @param  {Array}  items       Array of Zabbix item objects\n   * @param  {Number} timeFrom   Time in seconds\n   * @param  {Number} timeTill   Time in seconds\n   * @return {Array}  Array of Zabbix history objects\n   */\n  getHistory(items, timeFrom, timeTill) {\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid');\n      let params = {\n        output: 'extend',\n        history: value_type,\n        itemids: itemids,\n        sortfield: 'clock',\n        sortorder: 'ASC',\n        time_from: timeFrom\n      };\n\n      // Relative queries (e.g. last hour) don't include an end time\n      if (timeTill) {\n        params.time_till = timeTill;\n      }\n\n      return this.request('history.get', params);\n    });\n\n    return Promise.all(promises).then(_.flatten);\n  }\n\n  /**\n   * Perform trends query from Zabbix API\n   * Use trends api extension from ZBXNEXT-1193 patch.\n   *\n   * @param  {Array}  items       Array of Zabbix item objects\n   * @param  {Number} time_from   Time in seconds\n   * @param  {Number} time_till   Time in seconds\n   * @return {Array}  Array of Zabbix trend objects\n   */\n  getTrend_ZBXNEXT1193(items, timeFrom, timeTill) {\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid');\n      let params = {\n        output: 'extend',\n        trend: value_type,\n        itemids: itemids,\n        sortfield: 'clock',\n        sortorder: 'ASC',\n        time_from: timeFrom\n      };\n\n      // Relative queries (e.g. last hour) don't include an end time\n      if (timeTill) {\n        params.time_till = timeTill;\n      }\n\n      return this.request('trend.get', params);\n    });\n\n    return Promise.all(promises).then(_.flatten);\n  }\n\n  getTrend_30(items, time_from, time_till, value_type) {\n    var self = this;\n    var itemids = _.map(items, 'itemid');\n\n    var params = {\n      output: [\"itemid\",\n        \"clock\",\n        value_type\n      ],\n      itemids: itemids,\n      time_from: time_from\n    };\n\n    // Relative queries (e.g. last hour) don't include an end time\n    if (time_till) {\n      params.time_till = time_till;\n    }\n\n    return self.request('trend.get', params);\n  }\n\n  getITService(serviceids) {\n    var params = {\n      output: 'extend',\n      serviceids: serviceids\n    };\n    return this.request('service.get', params);\n  }\n\n  getSLA(serviceids, timeRange, options) {\n    const intervals = buildSLAIntervals(timeRange, options.intervalMs);\n    const params = {\n      serviceids,\n      intervals\n    };\n    return this.request('service.getsla', params);\n  }\n\n  getTriggers(groupids, hostids, applicationids, options) {\n    let {showTriggers, maintenance, timeFrom, timeTo} = options;\n\n    let params = {\n      output: 'extend',\n      groupids: groupids,\n      hostids: hostids,\n      applicationids: applicationids,\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      //only_true: true,\n      filter: {\n        value: 1\n      },\n      selectGroups: ['name'],\n      selectHosts: ['name', 'host', 'maintenance_status', 'proxy_hostid'],\n      selectItems: ['name', 'key_', 'lastvalue'],\n      selectLastEvent: 'extend',\n      selectTags: 'extend'\n    };\n\n    if (showTriggers) {\n      params.filter.value = showTriggers;\n    }\n\n    if (maintenance) {\n      params.maintenance = true;\n    }\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params);\n  }\n\n  getEvents(objectids, timeFrom, timeTo, showEvents, limit) {\n    var params = {\n      output: 'extend',\n      time_from: timeFrom,\n      time_till: timeTo,\n      objectids: objectids,\n      select_acknowledges: 'extend',\n      selectHosts: 'extend',\n      value: showEvents,\n    };\n\n    if (limit) {\n      params.limit = limit;\n      params.sortfield = 'clock';\n      params.sortorder = 'DESC';\n    }\n\n    return this.request('event.get', params);\n  }\n\n  getAcknowledges(eventids) {\n    var params = {\n      output: 'extend',\n      eventids: eventids,\n      preservekeys: true,\n      select_acknowledges: 'extend',\n      sortfield: 'clock',\n      sortorder: 'DESC'\n    };\n\n    return this.request('event.get', params)\n    .then(events => {\n      return _.filter(events, (event) => event.acknowledges.length);\n    });\n  }\n\n  getExtendedEventData(eventids) {\n    var params = {\n      output: 'extend',\n      eventids: eventids,\n      preservekeys: true,\n      select_acknowledges: 'extend',\n      selectTags: 'extend',\n      sortfield: 'clock',\n      sortorder: 'DESC'\n    };\n\n    return this.request('event.get', params);\n  }\n\n  getEventAlerts(eventids) {\n    const params = {\n      eventids: eventids,\n      output: [\n        'eventid',\n        'message',\n        'clock',\n        'error'\n      ],\n      selectUsers: true,\n    };\n\n    return this.request('alert.get', params);\n  }\n\n  getAlerts(itemids, timeFrom, timeTo) {\n    var params = {\n      output: 'extend',\n      itemids: itemids,\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      //only_true: true,\n      // filter: {\n      //   value: 1\n      // },\n      selectLastEvent: 'extend'\n    };\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params);\n  }\n\n  getHostAlerts(hostids, applicationids, options) {\n    let {minSeverity, acknowledged, count, timeFrom, timeTo} = options;\n    let params = {\n      output: 'extend',\n      hostids: hostids,\n      min_severity: minSeverity,\n      filter: { value: 1 },\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      selectLastEvent: 'extend',\n      selectGroups: 'extend',\n      selectHosts: ['host', 'name']\n    };\n\n    if (count && acknowledged !== 0 && acknowledged !== 1) {\n      params.countOutput = true;\n    }\n\n    if (applicationids && applicationids.length) {\n      params.applicationids = applicationids;\n    }\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params)\n    .then((triggers) => {\n      if (!count || acknowledged === 0 || acknowledged === 1) {\n        triggers = filterTriggersByAcknowledge(triggers, acknowledged);\n        if (count) {\n          triggers = triggers.length;\n        }\n      }\n      return triggers;\n    });\n  }\n\n  getProxies() {\n    var params = {\n      output: ['proxyid', 'host'],\n    };\n\n    return this.request('proxy.get', params);\n  }\n}\n\nfunction filterTriggersByAcknowledge(triggers, acknowledged) {\n  if (acknowledged === 0) {\n    return _.filter(triggers, (trigger) => trigger.lastEvent.acknowledged === \"0\");\n  } else if (acknowledged === 1) {\n    return _.filter(triggers, (trigger) => trigger.lastEvent.acknowledged === \"1\");\n  } else {\n    return triggers;\n  }\n}\n\nfunction isNotAuthorized(message) {\n  return (\n    message === \"Session terminated, re-login, please.\" ||\n    message === \"Not authorised.\" ||\n    message === \"Not authorized.\"\n  );\n}\n\nfunction getSLAInterval(intervalMs) {\n  // Too many intervals may cause significant load on the database, so decrease number of resulting points\n  const resolutionRatio = 100;\n  const interval = kbn.round_interval(intervalMs * resolutionRatio) / 1000;\n  return Math.max(interval, MIN_SLA_INTERVAL);\n}\n\nfunction buildSLAIntervals(timeRange, intervalMs) {\n  let [timeFrom, timeTo] = timeRange;\n  const slaInterval = getSLAInterval(intervalMs);\n  const intervals = [];\n\n  // Align time range with calculated interval\n  timeFrom = Math.floor(timeFrom / slaInterval) * slaInterval;\n  timeTo = Math.ceil(timeTo / slaInterval) * slaInterval;\n\n  for (let i = timeFrom; i <= timeTo - slaInterval; i += slaInterval) {\n    intervals.push({\n      from : i,\n      to : (i + slaInterval)\n    });\n\n  }\n\n  return intervals;\n}\n","/**\n * MySQL queries\n */\n\nfunction historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let time_expression = `clock DIV ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT CAST(itemid AS CHAR) AS metric, ${time_expression} AS time_sec, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY ${time_expression}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nfunction trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let time_expression = `clock DIV ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT CAST(itemid AS CHAR) AS metric, ${time_expression} AS time_sec, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY ${time_expression}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nconst TEST_QUERY = `SELECT CAST(itemid AS CHAR) AS metric, clock AS time_sec, value_avg AS value FROM trends_uint LIMIT 1`;\n\nfunction testQuery() {\n  return TEST_QUERY;\n}\n\nconst mysql = {\n  historyQuery,\n  trendsQuery,\n  testQuery\n};\n\nexport default mysql;\n","/**\n * Postgres queries\n */\n\nconst ITEMID_FORMAT = 'FM99999999999999999999';\n\nfunction historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, ${time_expression} AS time, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nfunction trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, ${time_expression} AS time, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nconst TEST_QUERY = `\n  SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, clock AS time, value_avg AS value\n  FROM trends_uint LIMIT 1\n`;\n\nfunction testQuery() {\n  return TEST_QUERY;\n}\n\nconst postgres = {\n  historyQuery,\n  trendsQuery,\n  testQuery\n};\n\nexport default postgres;\n","import _ from 'lodash';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { compactQuery } from '../../../utils';\nimport mysql from './mysql';\nimport postgres from './postgres';\nimport dbConnector, { DBConnector, DEFAULT_QUERY_LIMIT, HISTORY_TO_TABLE_MAP, TREND_TO_TABLE_MAP } from '../dbConnector';\n\nconst supportedDatabases = {\n  mysql: 'mysql',\n  postgres: 'postgres'\n};\n\nexport class SQLConnector extends DBConnector {\n  constructor(options) {\n    super(options);\n\n    this.limit = options.limit || DEFAULT_QUERY_LIMIT;\n    this.sqlDialect = null;\n\n    super.loadDBDataSource()\n    .then(() => {\n      this.loadSQLDialect();\n    });\n  }\n\n  loadSQLDialect() {\n    if (this.datasourceTypeId === supportedDatabases.postgres) {\n      this.sqlDialect = postgres;\n    } else {\n      this.sqlDialect = mysql;\n    }\n  }\n\n  /**\n   * Try to invoke test query for one of Zabbix database tables.\n   */\n  testDataSource() {\n    let testQuery = this.sqlDialect.testQuery();\n    return this.invokeSQLQuery(testQuery);\n  }\n\n  getHistory(items, timeFrom, timeTill, options) {\n    let {intervalMs, consolidateBy} = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = dbConnector.consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = HISTORY_TO_TABLE_MAP[value_type];\n      let query = this.sqlDialect.historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction);\n\n      query = compactQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  getTrends(items, timeFrom, timeTill, options) {\n    let { intervalMs, consolidateBy } = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = dbConnector.consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = TREND_TO_TABLE_MAP[value_type];\n      let valueColumn = _.includes(['avg', 'min', 'max', 'sum'], consolidateBy) ? consolidateBy : 'avg';\n      valueColumn = dbConnector.consolidateByTrendColumns[valueColumn];\n      let query = this.sqlDialect.trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn);\n\n      query = compactQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  invokeSQLQuery(query) {\n    let queryDef = {\n      refId: 'A',\n      format: 'time_series',\n      datasourceId: this.datasourceId,\n      rawSql: query,\n      maxDataPoints: this.limit\n    };\n\n    return getBackendSrv().datasourceRequest({\n      url: '/api/tsdb/query',\n      method: 'POST',\n      data: {\n        queries: [queryDef],\n      }\n    })\n    .then(response => {\n      let results = response.data.results;\n      if (results['A']) {\n        return results['A'].series;\n      } else {\n        return null;\n      }\n    });\n  }\n}\n","import _ from 'lodash';\nimport { compactQuery } from '../../../utils';\nimport { DBConnector, HISTORY_TO_TABLE_MAP, consolidateByTrendColumns } from '../dbConnector';\n\nconst consolidateByFunc = {\n  'avg': 'MEAN',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\nexport class InfluxDBConnector extends DBConnector {\n  constructor(options) {\n    super(options);\n    this.retentionPolicy = options.retentionPolicy;\n    super.loadDBDataSource().then(ds => {\n      this.influxDS = ds;\n      return ds;\n    });\n  }\n\n  /**\n   * Try to invoke test query for one of Zabbix database tables.\n   */\n  testDataSource() {\n    return this.influxDS.testDatasource();\n  }\n\n  getHistory(items, timeFrom, timeTill, options) {\n    let { intervalMs, consolidateBy, retentionPolicy } = options;\n    const intervalSec = Math.ceil(intervalMs / 1000);\n\n    const range = { timeFrom, timeTill };\n    consolidateBy = consolidateBy || 'avg';\n\n    // Group items by value type and perform request for each value type\n    const grouped_items = _.groupBy(items, 'value_type');\n    const promises = _.map(grouped_items, (items, value_type) => {\n      const itemids = _.map(items, 'itemid');\n      const table = HISTORY_TO_TABLE_MAP[value_type];\n      const query = this.buildHistoryQuery(itemids, table, range, intervalSec, consolidateBy, retentionPolicy);\n      return this.invokeInfluxDBQuery(query);\n    });\n\n    return Promise.all(promises)\n    .then(_.flatten)\n    .then(results => {\n      return handleInfluxHistoryResponse(results);\n    });\n  }\n\n  getTrends(items, timeFrom, timeTill, options) {\n    options.retentionPolicy = this.retentionPolicy;\n    return this.getHistory(items, timeFrom, timeTill, options);\n  }\n\n  buildHistoryQuery(itemids, table, range, intervalSec, aggFunction, retentionPolicy) {\n    const { timeFrom, timeTill } = range;\n    const measurement = retentionPolicy ? `\"${retentionPolicy}\".\"${table}\"` : `\"${table}\"`;\n    let value = 'value';\n    if (retentionPolicy) {\n      value = consolidateByTrendColumns[aggFunction] || 'value_avg';\n    }\n    const aggregation = consolidateByFunc[aggFunction] || aggFunction;\n    const where_clause = this.buildWhereClause(itemids);\n    const query = `SELECT ${aggregation}(\"${value}\") FROM ${measurement}\n      WHERE ${where_clause} AND \"time\" >= ${timeFrom}s AND \"time\" <= ${timeTill}s\n      GROUP BY time(${intervalSec}s), \"itemid\" fill(none)`;\n    return compactQuery(query);\n  }\n\n  buildWhereClause(itemids) {\n    const itemidsWhere = itemids.map(itemid => `\"itemid\" = '${itemid}'`).join(' OR ');\n    return `(${itemidsWhere})`;\n  }\n\n  invokeInfluxDBQuery(query) {\n    return this.influxDS._seriesQuery(query)\n    .then(data => data && data.results ? data.results : []);\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nfunction handleInfluxHistoryResponse(results) {\n  if (!results) {\n    return [];\n  }\n\n  const seriesList = [];\n  for (let i = 0; i < results.length; i++) {\n    const result = results[i];\n\n    if (result.error) {\n      const error = `InfluxDB error: ${result.error}`;\n      return Promise.reject(new Error(error));\n    }\n\n    if (!result || !result.series) {\n      continue;\n    }\n\n    const influxSeriesList = results[i].series;\n\n    for (let y = 0; y < influxSeriesList.length; y++) {\n      const influxSeries = influxSeriesList[y];\n      const datapoints = [];\n      if (influxSeries.values) {\n        for (i = 0; i < influxSeries.values.length; i++) {\n          datapoints[i] = [influxSeries.values[i][1], influxSeries.values[i][0]];\n        }\n      }\n      const timeSeries = {\n        name: influxSeries.tags.itemid,\n        points: datapoints\n      };\n      seriesList.push(timeSeries);\n    }\n  }\n\n  return seriesList;\n}\n","import _ from 'lodash';\nimport * as utils from '../utils';\nimport responseHandler from '../responseHandler';\nimport { CachingProxy } from './proxy/cachingProxy';\nimport { ZabbixNotImplemented } from './connectors/dbConnector';\nimport { DBConnector } from './connectors/dbConnector';\nimport { ZabbixAPIConnector } from './connectors/zabbix_api/zabbixAPIConnector';\nimport { SQLConnector } from './connectors/sql/sqlConnector';\nimport { InfluxDBConnector } from './connectors/influxdb/influxdbConnector';\n\nconst REQUESTS_TO_PROXYFY = [\n  'getHistory', 'getTrend', 'getGroups', 'getHosts', 'getApps', 'getItems', 'getMacros', 'getItemsByIDs',\n  'getEvents', 'getAlerts', 'getHostAlerts', 'getAcknowledges', 'getITService', 'getSLA', 'getVersion', 'getProxies',\n  'getEventAlerts', 'getExtendedEventData'\n];\n\nconst REQUESTS_TO_CACHE = [\n  'getGroups', 'getHosts', 'getApps', 'getItems', 'getMacros', 'getItemsByIDs', 'getITService', 'getProxies'\n];\n\nconst REQUESTS_TO_BIND = [\n  'getHistory', 'getTrend', 'getMacros', 'getItemsByIDs', 'getEvents', 'getAlerts', 'getHostAlerts',\n  'getAcknowledges', 'getITService', 'getVersion', 'login', 'acknowledgeEvent', 'getProxies', 'getEventAlerts',\n  'getExtendedEventData'\n];\n\nexport class Zabbix {\n  constructor(options) {\n    let {\n      url,\n      username,\n      password,\n      basicAuth,\n      withCredentials,\n      zabbixVersion,\n      cacheTTL,\n      enableDirectDBConnection,\n      dbConnectionDatasourceId,\n      dbConnectionDatasourceName,\n      dbConnectionRetentionPolicy,\n    } = options;\n\n    this.enableDirectDBConnection = enableDirectDBConnection;\n\n    // Initialize caching proxy for requests\n    let cacheOptions = {\n      enabled: true,\n      ttl: cacheTTL\n    };\n    this.cachingProxy = new CachingProxy(cacheOptions);\n\n    this.zabbixAPI = new ZabbixAPIConnector(url, username, password, zabbixVersion, basicAuth, withCredentials);\n\n    this.proxyfyRequests();\n    this.cacheRequests();\n    this.bindRequests();\n\n    if (enableDirectDBConnection) {\n      const connectorOptions = { dbConnectionRetentionPolicy };\n      this.initDBConnector(dbConnectionDatasourceId, dbConnectionDatasourceName, connectorOptions)\n      .then(() => {\n        this.getHistoryDB = this.cachingProxy.proxyfyWithCache(this.dbConnector.getHistory, 'getHistory', this.dbConnector);\n        this.getTrendsDB = this.cachingProxy.proxyfyWithCache(this.dbConnector.getTrends, 'getTrends', this.dbConnector);\n      });\n    }\n  }\n\n  initDBConnector(datasourceId, datasourceName, options) {\n    return DBConnector.loadDatasource(datasourceId, datasourceName)\n    .then(ds => {\n      let connectorOptions = { datasourceId, datasourceName };\n      if (ds.type === 'influxdb') {\n        connectorOptions.retentionPolicy = options.dbConnectionRetentionPolicy;\n        this.dbConnector = new InfluxDBConnector(connectorOptions);\n      } else {\n        this.dbConnector = new SQLConnector(connectorOptions);\n      }\n      return this.dbConnector;\n    });\n  }\n\n  proxyfyRequests() {\n    for (let request of REQUESTS_TO_PROXYFY) {\n      this.zabbixAPI[request] = this.cachingProxy.proxyfy(this.zabbixAPI[request], request, this.zabbixAPI);\n    }\n  }\n\n  cacheRequests() {\n    for (let request of REQUESTS_TO_CACHE) {\n      this.zabbixAPI[request] = this.cachingProxy.cacheRequest(this.zabbixAPI[request], request, this.zabbixAPI);\n    }\n  }\n\n  bindRequests() {\n    for (let request of REQUESTS_TO_BIND) {\n      this[request] = this.zabbixAPI[request].bind(this.zabbixAPI);\n    }\n  }\n\n  /**\n   * Perform test query for Zabbix API and external history DB.\n   * @return {object} test result object:\n   * ```\n    {\n      zabbixVersion,\n      dbConnectorStatus: {\n        dsType,\n        dsName\n      }\n    }\n   ```\n   */\n  testDataSource() {\n    let zabbixVersion;\n    let dbConnectorStatus;\n    return this.getVersion()\n    .then(version => {\n      zabbixVersion = version;\n      return this.login();\n    })\n    .then(() => {\n      if (this.enableDirectDBConnection) {\n        return this.dbConnector.testDataSource();\n      } else {\n        return Promise.resolve();\n      }\n    })\n    .catch(error => {\n      if (error instanceof ZabbixNotImplemented) {\n        return Promise.resolve();\n      }\n      return Promise.reject(error);\n    })\n    .then(testResult => {\n      if (testResult) {\n        dbConnectorStatus = {\n          dsType: this.dbConnector.datasourceTypeName,\n          dsName: this.dbConnector.datasourceName\n        };\n      }\n      return { zabbixVersion, dbConnectorStatus };\n    });\n  }\n\n  getItemsFromTarget(target, options) {\n    let parts = ['group', 'host', 'application', 'item'];\n    let filters = _.map(parts, p => target[p].filter);\n    return this.getItems(...filters, options);\n  }\n\n  getHostsFromTarget(target) {\n    let parts = ['group', 'host', 'application'];\n    let filters = _.map(parts, p => target[p].filter);\n    return Promise.all([\n      this.getHosts(...filters),\n      this.getApps(...filters),\n    ]).then((results) => {\n      let [hosts, apps] = results;\n      if (apps.appFilterEmpty) {\n        apps = [];\n      }\n      return [hosts, apps];\n    });\n  }\n\n  getAllGroups() {\n    return this.zabbixAPI.getGroups();\n  }\n\n  getGroups(groupFilter) {\n    return this.getAllGroups()\n    .then(groups => findByFilter(groups, groupFilter));\n  }\n\n  /**\n   * Get list of host belonging to given groups.\n   */\n  getAllHosts(groupFilter) {\n    return this.getGroups(groupFilter)\n    .then(groups => {\n      let groupids = _.map(groups, 'groupid');\n      return this.zabbixAPI.getHosts(groupids);\n    });\n  }\n\n  getHosts(groupFilter, hostFilter) {\n    return this.getAllHosts(groupFilter)\n    .then(hosts => findByFilter(hosts, hostFilter));\n  }\n\n  /**\n   * Get list of applications belonging to given groups and hosts.\n   */\n  getAllApps(groupFilter, hostFilter) {\n    return this.getHosts(groupFilter, hostFilter)\n    .then(hosts => {\n      let hostids = _.map(hosts, 'hostid');\n      return this.zabbixAPI.getApps(hostids);\n    });\n  }\n\n  getApps(groupFilter, hostFilter, appFilter) {\n    return this.getHosts(groupFilter, hostFilter)\n    .then(hosts => {\n      let hostids = _.map(hosts, 'hostid');\n      if (appFilter) {\n        return this.zabbixAPI.getApps(hostids)\n        .then(apps => filterByQuery(apps, appFilter));\n      } else {\n        return {\n          appFilterEmpty: true,\n          hostids: hostids\n        };\n      }\n    });\n  }\n\n  getAllItems(groupFilter, hostFilter, appFilter, options = {}) {\n    return this.getApps(groupFilter, hostFilter, appFilter)\n    .then(apps => {\n      if (apps.appFilterEmpty) {\n        return this.zabbixAPI.getItems(apps.hostids, undefined, options.itemtype);\n      } else {\n        let appids = _.map(apps, 'applicationid');\n        return this.zabbixAPI.getItems(undefined, appids, options.itemtype);\n      }\n    })\n    .then(items => {\n      if (!options.showDisabledItems) {\n        items = _.filter(items, {'status': '0'});\n      }\n\n      return items;\n    })\n    .then(this.expandUserMacro.bind(this));\n  }\n\n  expandUserMacro(items) {\n    let hostids = getHostIds(items);\n    return this.getMacros(hostids)\n    .then(macros => {\n      _.forEach(items, item => {\n        if (utils.containsMacro(item.name)) {\n          item.name = utils.replaceMacro(item, macros);\n        }\n      });\n      return items;\n    });\n  }\n\n  getItems(groupFilter, hostFilter, appFilter, itemFilter, options = {}) {\n    return this.getAllItems(groupFilter, hostFilter, appFilter, options)\n    .then(items => filterByQuery(items, itemFilter));\n  }\n\n  getITServices(itServiceFilter) {\n    return this.zabbixAPI.getITService()\n    .then(itServices => findByFilter(itServices, itServiceFilter));\n  }\n\n  /**\n   * Build query - convert target filters to array of Zabbix items\n   */\n  getTriggers(groupFilter, hostFilter, appFilter, options, proxyFilter) {\n    let promises = [\n      this.getGroups(groupFilter),\n      this.getHosts(groupFilter, hostFilter),\n      this.getApps(groupFilter, hostFilter, appFilter)\n    ];\n\n    return Promise.all(promises)\n    .then(results => {\n      let [filteredGroups, filteredHosts, filteredApps] = results;\n      let query = {};\n\n      if (appFilter) {\n        query.applicationids = _.flatten(_.map(filteredApps, 'applicationid'));\n      }\n      if (hostFilter) {\n        query.hostids = _.map(filteredHosts, 'hostid');\n      }\n      if (groupFilter) {\n        query.groupids = _.map(filteredGroups, 'groupid');\n      }\n\n      return query;\n    })\n    .then(query => this.zabbixAPI.getTriggers(query.groupids, query.hostids, query.applicationids, options))\n    .then(triggers => this.filterTriggersByProxy(triggers, proxyFilter));\n  }\n\n  filterTriggersByProxy(triggers, proxyFilter) {\n    return this.getFilteredProxies(proxyFilter)\n    .then(proxies => {\n      if (proxyFilter && proxyFilter !== '/.*/' && triggers) {\n        const proxy_ids = proxies.map(proxy => proxy.proxyid);\n        triggers = triggers.filter(trigger => {\n          let filtered = false;\n          for(let i = 0; i < trigger.hosts.length; i++) {\n            const host = trigger.hosts[i];\n            if (proxy_ids.includes(host.proxy_hostid)) {\n              filtered = true;\n            }\n          }\n          return filtered;\n        });\n      }\n      return triggers;\n    });\n  }\n\n  getFilteredProxies(proxyFilter) {\n    return this.zabbixAPI.getProxies()\n    .then(proxies => {\n      proxies.forEach(proxy => proxy.name = proxy.host);\n      return findByFilter(proxies, proxyFilter);\n    });\n  }\n\n  getHistoryTS(items, timeRange, options) {\n    let [timeFrom, timeTo] = timeRange;\n    if (this.enableDirectDBConnection) {\n      return this.getHistoryDB(items, timeFrom, timeTo, options)\n      .then(history => this.dbConnector.handleGrafanaTSResponse(history, items));\n    } else {\n      return this.zabbixAPI.getHistory(items, timeFrom, timeTo)\n      .then(history => responseHandler.handleHistory(history, items));\n    }\n  }\n\n  getTrends(items, timeRange, options) {\n    let [timeFrom, timeTo] = timeRange;\n    if (this.enableDirectDBConnection) {\n      return this.getTrendsDB(items, timeFrom, timeTo, options)\n      .then(history => this.dbConnector.handleGrafanaTSResponse(history, items));\n    } else {\n      let valueType = options.consolidateBy || options.valueType;\n      return this.zabbixAPI.getTrend(items, timeFrom, timeTo)\n      .then(history => responseHandler.handleTrends(history, items, valueType))\n      .then(responseHandler.sortTimeseries); // Sort trend data, issue #202\n    }\n  }\n\n  getHistoryText(items, timeRange, target) {\n    let [timeFrom, timeTo] = timeRange;\n    if (items.length) {\n      return this.zabbixAPI.getHistory(items, timeFrom, timeTo)\n      .then(history => {\n        if (target.resultFormat === 'table') {\n          return responseHandler.handleHistoryAsTable(history, items, target);\n        } else {\n          return responseHandler.handleText(history, items, target);\n        }\n      });\n    } else {\n      return Promise.resolve([]);\n    }\n  }\n\n  getSLA(itservices, timeRange, target, options) {\n    let itServices = itservices;\n    if (options.isOldVersion) {\n      itServices = _.filter(itServices, {'serviceid': target.itservice.serviceid});\n    }\n    let itServiceIds = _.map(itServices, 'serviceid');\n    return this.zabbixAPI.getSLA(itServiceIds, timeRange, options)\n    .then(slaResponse => {\n      return _.map(itServiceIds, serviceid => {\n        let itservice = _.find(itServices, {'serviceid': serviceid});\n        return responseHandler.handleSLAResponse(itservice, target.slaProperty, slaResponse);\n      });\n    });\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Find group, host, app or item by given name.\n * @param  list list of groups, apps or other\n * @param  name visible name\n * @return      array with finded element or empty array\n */\nfunction findByName(list, name) {\n  var finded = _.find(list, {'name': name});\n  if (finded) {\n    return [finded];\n  } else {\n    return [];\n  }\n}\n\n/**\n * Different hosts can contains applications and items with same name.\n * For this reason use _.filter, which return all elements instead _.find,\n * which return only first finded.\n * @param  {[type]} list list of elements\n * @param  {[type]} name app name\n * @return {[type]}      array with finded element or empty array\n */\nfunction filterByName(list, name) {\n  var finded = _.filter(list, {'name': name});\n  if (finded) {\n    return finded;\n  } else {\n    return [];\n  }\n}\n\nfunction filterByRegex(list, regex) {\n  var filterPattern = utils.buildRegex(regex);\n  return _.filter(list, function (zbx_obj) {\n    return filterPattern.test(zbx_obj.name);\n  });\n}\n\nfunction findByFilter(list, filter) {\n  if (utils.isRegex(filter)) {\n    return filterByRegex(list, filter);\n  } else {\n    return findByName(list, filter);\n  }\n}\n\nfunction filterByQuery(list, filter) {\n  if (utils.isRegex(filter)) {\n    return filterByRegex(list, filter);\n  } else {\n    return filterByName(list, filter);\n  }\n}\n\nfunction getHostIds(items) {\n  let hostIds = _.map(items, item => {\n    return _.map(item.hosts, 'hostid');\n  });\n  return _.uniq(_.flatten(hostIds));\n}\n","import _ from 'lodash';\nimport config from 'grafana/app/core/config';\nimport * as dateMath from 'grafana/app/core/utils/datemath';\nimport * as utils from './utils';\nimport * as migrations from './migrations';\nimport * as metricFunctions from './metricFunctions';\nimport * as c from './constants';\nimport dataProcessor from './dataProcessor';\nimport responseHandler from './responseHandler';\nimport { Zabbix } from './zabbix/zabbix';\nimport { ZabbixAPIError } from './zabbix/connectors/zabbix_api/zabbixAPICore';\nimport { VariableQueryTypes } from './types';\n\nconst DEFAULT_ZABBIX_VERSION = 3;\n\nexport class ZabbixDatasource {\n\n  /** @ngInject */\n  constructor(instanceSettings, templateSrv, zabbixAlertingSrv) {\n    this.templateSrv = templateSrv;\n    this.zabbixAlertingSrv = zabbixAlertingSrv;\n\n    this.enableDebugLog = config.buildInfo.env === 'development';\n\n    // Use custom format for template variables\n    this.replaceTemplateVars = _.partial(replaceTemplateVars, this.templateSrv);\n\n    // General data source settings\n    this.name             = instanceSettings.name;\n    this.url              = instanceSettings.url;\n    this.basicAuth        = instanceSettings.basicAuth;\n    this.withCredentials  = instanceSettings.withCredentials;\n\n    const jsonData = migrations.migrateDSConfig(instanceSettings.jsonData);\n\n    // Zabbix API credentials\n    this.username         = jsonData.username;\n    this.password         = jsonData.password;\n\n    // Use trends instead history since specified time\n    this.trends           = jsonData.trends;\n    this.trendsFrom       = jsonData.trendsFrom || '7d';\n    this.trendsRange      = jsonData.trendsRange || '4d';\n\n    // Set cache update interval\n    var ttl = jsonData.cacheTTL || '1h';\n    this.cacheTTL = utils.parseInterval(ttl);\n\n    // Alerting options\n    this.alertingEnabled =     jsonData.alerting;\n    this.addThresholds =       jsonData.addThresholds;\n    this.alertingMinSeverity = jsonData.alertingMinSeverity || c.SEV_WARNING;\n\n    // Other options\n    this.disableReadOnlyUsersAck = jsonData.disableReadOnlyUsersAck;\n    this.zabbixVersion = jsonData.zabbixVersion || DEFAULT_ZABBIX_VERSION;\n\n    // Direct DB Connection options\n    this.enableDirectDBConnection = jsonData.dbConnectionEnable || false;\n    this.dbConnectionDatasourceId = jsonData.dbConnectionDatasourceId;\n    this.dbConnectionDatasourceName = jsonData.dbConnectionDatasourceName;\n    this.dbConnectionRetentionPolicy = jsonData.dbConnectionRetentionPolicy;\n\n    let zabbixOptions = {\n      url: this.url,\n      username: this.username,\n      password: this.password,\n      basicAuth: this.basicAuth,\n      withCredentials: this.withCredentials,\n      zabbixVersion: this.zabbixVersion,\n      cacheTTL: this.cacheTTL,\n      enableDirectDBConnection: this.enableDirectDBConnection,\n      dbConnectionDatasourceId: this.dbConnectionDatasourceId,\n      dbConnectionDatasourceName: this.dbConnectionDatasourceName,\n      dbConnectionRetentionPolicy: this.dbConnectionRetentionPolicy,\n    };\n\n    this.zabbix = new Zabbix(zabbixOptions);\n  }\n\n  ////////////////////////\n  // Datasource methods //\n  ////////////////////////\n\n  /**\n   * Query panel data. Calls for each panel in dashboard.\n   * @param  {Object} options   Contains time range, targets and other info.\n   * @return {Object} Grafana metrics object with timeseries data for each target.\n   */\n  query(options) {\n    // Get alerts for current panel\n    if (this.alertingEnabled) {\n      this.alertQuery(options).then(alert => {\n        this.zabbixAlertingSrv.setPanelAlertState(options.panelId, alert.state);\n\n        this.zabbixAlertingSrv.removeZabbixThreshold(options.panelId);\n        if (this.addThresholds) {\n          _.forEach(alert.thresholds, threshold => {\n            this.zabbixAlertingSrv.setPanelThreshold(options.panelId, threshold);\n          });\n        }\n      });\n    }\n\n    // Create request for each target\n    let promises = _.map(options.targets, t => {\n      // Don't request for hidden targets\n      if (t.hide) {\n        return [];\n      }\n\n      let timeFrom = Math.ceil(dateMath.parse(options.range.from) / 1000);\n      let timeTo = Math.ceil(dateMath.parse(options.range.to) / 1000);\n\n      // Add range variables\n      options.scopedVars = Object.assign({}, options.scopedVars, utils.getRangeScopedVars(options.range));\n\n      // Prevent changes of original object\n      let target = _.cloneDeep(t);\n\n      // Migrate old targets\n      target = migrations.migrate(target);\n      this.replaceTargetVariables(target, options);\n\n      // Apply Time-related functions (timeShift(), etc)\n      let timeFunctions = bindFunctionDefs(target.functions, 'Time');\n      if (timeFunctions.length) {\n        const [time_from, time_to] = utils.sequence(timeFunctions)([timeFrom, timeTo]);\n        timeFrom = time_from;\n        timeTo = time_to;\n      }\n      let timeRange = [timeFrom, timeTo];\n\n      let useTrends = this.isUseTrends(timeRange);\n\n      // Metrics or Text query mode\n      if (!target.mode || target.mode === c.MODE_METRICS || target.mode === c.MODE_TEXT) {\n        // Don't request undefined targets\n        if (!target.group || !target.host || !target.item) {\n          return [];\n        }\n\n        if (!target.mode || target.mode === c.MODE_METRICS) {\n          return this.queryNumericData(target, timeRange, useTrends, options);\n        } else if (target.mode === c.MODE_TEXT) {\n          return this.queryTextData(target, timeRange);\n        }\n      } else if (target.mode === c.MODE_ITEMID) {\n        // Item ID mode\n        if (!target.itemids) {\n          return [];\n        }\n        return this.queryItemIdData(target, timeRange, useTrends, options);\n      } else if (target.mode === c.MODE_ITSERVICE) {\n        // IT services mode\n        return this.queryITServiceData(target, timeRange, options);\n      } else if (target.mode === c.MODE_TRIGGERS) {\n        // Triggers mode\n        return this.queryTriggersData(target, timeRange);\n      } else {\n        return [];\n      }\n    });\n\n    // Data for panel (all targets)\n    return Promise.all(_.flatten(promises))\n      .then(_.flatten)\n      .then(data => {\n        return { data: data };\n      });\n  }\n\n  /**\n   * Query target data for Metrics mode\n   */\n  queryNumericData(target, timeRange, useTrends, options) {\n    let queryStart, queryEnd;\n    let getItemOptions = {\n      itemtype: 'num'\n    };\n    return this.zabbix.getItemsFromTarget(target, getItemOptions)\n    .then(items => {\n      queryStart = new Date().getTime();\n      return this.queryNumericDataForItems(items, target, timeRange, useTrends, options);\n    }).then(result => {\n      queryEnd = new Date().getTime();\n      if (this.enableDebugLog) {\n        console.debug(`Datasource::Performance Query Time (${this.name}): ${queryEnd - queryStart}`);\n      }\n      return result;\n    });\n  }\n\n  /**\n   * Query history for numeric items\n   */\n  queryNumericDataForItems(items, target, timeRange, useTrends, options) {\n    let getHistoryPromise;\n    options.valueType = this.getTrendValueType(target);\n    options.consolidateBy = getConsolidateBy(target) || options.valueType;\n\n    if (useTrends) {\n      getHistoryPromise = this.zabbix.getTrends(items, timeRange, options);\n    } else {\n      getHistoryPromise = this.zabbix.getHistoryTS(items, timeRange, options);\n    }\n\n    return getHistoryPromise\n    .then(timeseries => this.applyDataProcessingFunctions(timeseries, target))\n    .then(timeseries => downsampleSeries(timeseries, options));\n  }\n\n  getTrendValueType(target) {\n    // Find trendValue() function and get specified trend value\n    var trendFunctions = _.map(metricFunctions.getCategories()['Trends'], 'name');\n    var trendValueFunc = _.find(target.functions, func => {\n      return _.includes(trendFunctions, func.def.name);\n    });\n    return trendValueFunc ? trendValueFunc.params[0] : \"avg\";\n  }\n\n  applyDataProcessingFunctions(timeseries_data, target) {\n    let transformFunctions   = bindFunctionDefs(target.functions, 'Transform');\n    let aggregationFunctions = bindFunctionDefs(target.functions, 'Aggregate');\n    let filterFunctions      = bindFunctionDefs(target.functions, 'Filter');\n    let aliasFunctions       = bindFunctionDefs(target.functions, 'Alias');\n\n    // Apply transformation functions\n    timeseries_data = _.cloneDeep(_.map(timeseries_data, timeseries => {\n      timeseries.datapoints = utils.sequence(transformFunctions)(timeseries.datapoints);\n      return timeseries;\n    }));\n\n    // Apply filter functions\n    if (filterFunctions.length) {\n      timeseries_data = utils.sequence(filterFunctions)(timeseries_data);\n    }\n\n    // Apply aggregations\n    if (aggregationFunctions.length) {\n      let dp = _.map(timeseries_data, 'datapoints');\n      dp = utils.sequence(aggregationFunctions)(dp);\n\n      let aggFuncNames = _.map(metricFunctions.getCategories()['Aggregate'], 'name');\n      let lastAgg = _.findLast(target.functions, func => {\n        return _.includes(aggFuncNames, func.def.name);\n      });\n\n      timeseries_data = [{\n        target: lastAgg.text,\n        datapoints: dp\n      }];\n    }\n\n    // Apply alias functions\n    _.forEach(timeseries_data, utils.sequence(aliasFunctions));\n\n    // Apply Time-related functions (timeShift(), etc)\n    // Find timeShift() function and get specified trend value\n    this.applyTimeShiftFunction(timeseries_data, target);\n\n    return timeseries_data;\n  }\n\n  applyTimeShiftFunction(timeseries_data, target) {\n    // Find timeShift() function and get specified interval\n    let timeShiftFunc = _.find(target.functions, (func) => {\n      return func.def.name === 'timeShift';\n    });\n    if (timeShiftFunc) {\n      let shift = timeShiftFunc.params[0];\n      _.forEach(timeseries_data, (series) => {\n        series.datapoints = dataProcessor.unShiftTimeSeries(shift, series.datapoints);\n      });\n    }\n  }\n\n  /**\n   * Query target data for Text mode\n   */\n  queryTextData(target, timeRange) {\n    let options = {\n      itemtype: 'text'\n    };\n    return this.zabbix.getItemsFromTarget(target, options)\n    .then(items => {\n      return this.zabbix.getHistoryText(items, timeRange, target);\n    });\n  }\n\n  /**\n   * Query target data for Item ID mode\n   */\n  queryItemIdData(target, timeRange, useTrends, options) {\n    let itemids = target.itemids;\n    itemids = this.templateSrv.replace(itemids, options.scopedVars, zabbixItemIdsTemplateFormat);\n    itemids = _.map(itemids.split(','), itemid => itemid.trim());\n\n    if (!itemids) {\n      return [];\n    }\n\n    return this.zabbix.getItemsByIDs(itemids)\n    .then(items => {\n      return this.queryNumericDataForItems(items, target, timeRange, useTrends, options);\n    });\n  }\n\n  /**\n   * Query target data for IT Services mode\n   */\n  queryITServiceData(target, timeRange, options) {\n    // Don't show undefined and hidden targets\n    if (target.hide || (!target.itservice && !target.itServiceFilter) || !target.slaProperty) {\n      return [];\n    }\n\n    let itServiceFilter;\n    options.isOldVersion = target.itservice && !target.itServiceFilter;\n\n    if (options.isOldVersion) {\n      // Backward compatibility\n      itServiceFilter = '/.*/';\n    } else {\n      itServiceFilter = this.replaceTemplateVars(target.itServiceFilter, options.scopedVars);\n    }\n\n    return this.zabbix.getITServices(itServiceFilter)\n    .then(itservices => {\n      return this.zabbix.getSLA(itservices, timeRange, target, options);})\n    .then(itservicesdp => this.applyDataProcessingFunctions(itservicesdp, target));\n  }\n\n  queryTriggersData(target, timeRange) {\n    let [timeFrom, timeTo] = timeRange;\n    return this.zabbix.getHostsFromTarget(target)\n    .then(results => {\n      let [hosts, apps] = results;\n      if (hosts.length) {\n        let hostids = _.map(hosts, 'hostid');\n        let appids = _.map(apps, 'applicationid');\n        let options = {\n          minSeverity: target.triggers.minSeverity,\n          acknowledged: target.triggers.acknowledged,\n          count: target.triggers.count,\n          timeFrom: timeFrom,\n          timeTo: timeTo\n        };\n        const groupFilter = target.group.filter;\n        return Promise.all([\n          this.zabbix.getHostAlerts(hostids, appids, options),\n          this.zabbix.getGroups(groupFilter)\n        ])\n        .then(([triggers, groups]) => {\n          return responseHandler.handleTriggersResponse(triggers, groups, timeRange);\n        });\n      } else {\n        return Promise.resolve([]);\n      }\n    });\n  }\n\n  /**\n   * Test connection to Zabbix API and external history DB.\n   */\n  testDatasource() {\n    return this.zabbix.testDataSource()\n    .then(result => {\n      const { zabbixVersion, dbConnectorStatus } = result;\n      let message = `Zabbix API version: ${zabbixVersion}`;\n      if (dbConnectorStatus) {\n        message += `, DB connector type: ${dbConnectorStatus.dsType}`;\n      }\n      return {\n        status: \"success\",\n        title: \"Success\",\n        message: message\n      };\n    })\n    .catch(error => {\n      if (error instanceof ZabbixAPIError) {\n        return {\n          status: \"error\",\n          title: error.message,\n          message: error.message\n        };\n      } else if (error.data && error.data.message) {\n        return {\n          status: \"error\",\n          title: \"Connection failed\",\n          message: \"Connection failed: \" + error.data.message\n        };\n      } else if (typeof(error) === 'string') {\n        return {\n          status: \"error\",\n          title: \"Connection failed\",\n          message: \"Connection failed: \" + error\n        };\n      } else {\n        console.log(error);\n        return {\n          status: \"error\",\n          title: \"Connection failed\",\n          message: \"Could not connect to given url\"\n        };\n      }\n    });\n  }\n\n  /**\n   * Get Zabbix version\n   */\n  getVersion() {\n    return this.zabbix.getVersion()\n    .then(version => {\n      const zabbixVersion = utils.parseVersion(version);\n      if (!zabbixVersion) {\n        return null;\n      }\n      return zabbixVersion.major;\n    });\n  }\n\n  ////////////////\n  // Templating //\n  ////////////////\n\n  /**\n   * Find metrics from templated request.\n   *\n   * @param  {string} query Query from Templating\n   * @return {string}       Metric name - group, host, app or item or list\n   *                        of metrics in \"{metric1,metcic2,...,metricN}\" format.\n   */\n  metricFindQuery(query) {\n    let resultPromise;\n    let queryModel = _.cloneDeep(query);\n\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    if (typeof query === 'string') {\n      // Backward compatibility\n      queryModel = utils.parseLegacyVariableQuery(query);\n    }\n\n    for (const prop of ['group', 'host', 'application', 'item']) {\n      queryModel[prop] = this.replaceTemplateVars(queryModel[prop], {});\n    }\n\n    switch (queryModel.queryType) {\n      case VariableQueryTypes.Group:\n        resultPromise = this.zabbix.getGroups(queryModel.group);\n        break;\n      case VariableQueryTypes.Host:\n        resultPromise = this.zabbix.getHosts(queryModel.group, queryModel.host);\n        break;\n      case VariableQueryTypes.Application:\n        resultPromise = this.zabbix.getApps(queryModel.group, queryModel.host, queryModel.application);\n        break;\n      case VariableQueryTypes.Item:\n        resultPromise = this.zabbix.getItems(queryModel.group, queryModel.host, queryModel.application, queryModel.item);\n        break;\n      default:\n        resultPromise = Promise.resolve([]);\n        break;\n    }\n\n    return resultPromise.then(metrics => {\n      return _.map(metrics, formatMetric);\n    });\n  }\n\n  /////////////////\n  // Annotations //\n  /////////////////\n\n  annotationQuery(options) {\n    const timeRange = options.range || options.rangeRaw;\n    const timeFrom = Math.ceil(dateMath.parse(timeRange.from) / 1000);\n    const timeTo = Math.ceil(dateMath.parse(timeRange.to) / 1000);\n    var annotation = options.annotation;\n    var showOkEvents = annotation.showOkEvents ? c.SHOW_ALL_EVENTS : c.SHOW_OK_EVENTS;\n\n    // Show all triggers\n    let triggersOptions = {\n      showTriggers: c.SHOW_ALL_TRIGGERS,\n      hideHostsInMaintenance: false\n    };\n\n    var getTriggers = this.zabbix.getTriggers(this.replaceTemplateVars(annotation.group, {}),\n                                              this.replaceTemplateVars(annotation.host, {}),\n                                              this.replaceTemplateVars(annotation.application, {}),\n                                              triggersOptions);\n\n    return getTriggers.then(triggers => {\n\n      // Filter triggers by description\n      let triggerName = this.replaceTemplateVars(annotation.trigger, {});\n      if (utils.isRegex(triggerName)) {\n        triggers = _.filter(triggers, trigger => {\n          return utils.buildRegex(triggerName).test(trigger.description);\n        });\n      } else if (triggerName) {\n        triggers = _.filter(triggers, trigger => {\n          return trigger.description === triggerName;\n        });\n      }\n\n      // Remove events below the chose severity\n      triggers = _.filter(triggers, trigger => {\n        return Number(trigger.priority) >= Number(annotation.minseverity);\n      });\n\n      var objectids = _.map(triggers, 'triggerid');\n      return this.zabbix\n        .getEvents(objectids, timeFrom, timeTo, showOkEvents)\n        .then(events => {\n          var indexedTriggers = _.keyBy(triggers, 'triggerid');\n\n          // Hide acknowledged events if option enabled\n          if (annotation.hideAcknowledged) {\n            events = _.filter(events, event => {\n              return !event.acknowledges.length;\n            });\n          }\n\n          return _.map(events, event => {\n            let tags;\n            if (annotation.showHostname) {\n              tags = _.map(event.hosts, 'name');\n            }\n\n            // Show event type (OK or Problem)\n            let title = Number(event.value) ? 'Problem' : 'OK';\n\n            let formatted_acknowledges = utils.formatAcknowledges(event.acknowledges);\n            return {\n              annotation: annotation,\n              time: event.clock * 1000,\n              title: title,\n              tags: tags,\n              text: indexedTriggers[event.objectid].description + formatted_acknowledges\n            };\n          });\n        });\n    });\n  }\n\n  /**\n   * Get triggers and its details for panel's targets\n   * Returns alert state ('ok' if no fired triggers, or 'alerting' if at least 1 trigger is fired)\n   * or empty object if no related triggers are finded.\n   */\n  alertQuery(options) {\n    let enabled_targets = filterEnabledTargets(options.targets);\n    let getPanelItems = _.map(enabled_targets, t => {\n      let target = _.cloneDeep(t);\n      target = migrations.migrate(target);\n      this.replaceTargetVariables(target, options);\n      return this.zabbix.getItemsFromTarget(target, {itemtype: 'num'});\n    });\n\n    return Promise.all(getPanelItems)\n    .then(results => {\n      let items = _.flatten(results);\n      let itemids = _.map(items, 'itemid');\n\n      if (itemids.length === 0) {\n        return [];\n      }\n      return this.zabbix.getAlerts(itemids);\n    })\n    .then(triggers => {\n      triggers = _.filter(triggers, trigger => {\n        return trigger.priority >= this.alertingMinSeverity;\n      });\n\n      if (!triggers || triggers.length === 0) {\n        return {};\n      }\n\n      let state = 'ok';\n\n      let firedTriggers = _.filter(triggers, {value: '1'});\n      if (firedTriggers.length) {\n        state = 'alerting';\n      }\n\n      let thresholds = _.map(triggers, trigger => {\n        return getTriggerThreshold(trigger.expression);\n      });\n\n      return {\n        panelId: options.panelId,\n        state: state,\n        thresholds: thresholds\n      };\n    });\n  }\n\n  // Replace template variables\n  replaceTargetVariables(target, options) {\n    let parts = ['group', 'host', 'application', 'item'];\n    _.forEach(parts, p => {\n      if (target[p] && target[p].filter) {\n        target[p].filter = this.replaceTemplateVars(target[p].filter, options.scopedVars);\n      }\n    });\n    target.textFilter = this.replaceTemplateVars(target.textFilter, options.scopedVars);\n\n    _.forEach(target.functions, func => {\n      func.params = _.map(func.params, param => {\n        if (typeof param === 'number') {\n          return +this.templateSrv.replace(param.toString(), options.scopedVars);\n        } else {\n          return this.templateSrv.replace(param, options.scopedVars);\n        }\n      });\n    });\n  }\n\n  isUseTrends(timeRange) {\n    let [timeFrom, timeTo] = timeRange;\n    let useTrendsFrom = Math.ceil(dateMath.parse('now-' + this.trendsFrom) / 1000);\n    let useTrendsRange = Math.ceil(utils.parseInterval(this.trendsRange) / 1000);\n    let useTrends = this.trends && (\n      (timeFrom < useTrendsFrom) ||\n      (timeTo - timeFrom > useTrendsRange)\n    );\n    return useTrends;\n  }\n}\n\nfunction bindFunctionDefs(functionDefs, category) {\n  var aggregationFunctions = _.map(metricFunctions.getCategories()[category], 'name');\n  var aggFuncDefs = _.filter(functionDefs, function(func) {\n    return _.includes(aggregationFunctions, func.def.name);\n  });\n\n  return _.map(aggFuncDefs, function(func) {\n    var funcInstance = metricFunctions.createFuncInstance(func.def, func.params);\n    return funcInstance.bindFunction(dataProcessor.metricFunctions);\n  });\n}\n\nfunction getConsolidateBy(target) {\n  let consolidateBy;\n  let funcDef = _.find(target.functions, func => {\n    return func.def.name === 'consolidateBy';\n  });\n  if (funcDef && funcDef.params && funcDef.params.length) {\n    consolidateBy = funcDef.params[0];\n  }\n  return consolidateBy;\n}\n\nfunction downsampleSeries(timeseries_data, options) {\n  let defaultAgg = dataProcessor.aggregationFunctions['avg'];\n  let consolidateByFunc = dataProcessor.aggregationFunctions[options.consolidateBy] || defaultAgg;\n  return _.map(timeseries_data, timeseries => {\n    if (timeseries.datapoints.length > options.maxDataPoints) {\n      timeseries.datapoints = dataProcessor\n        .groupBy(options.interval, consolidateByFunc, timeseries.datapoints);\n    }\n    return timeseries;\n  });\n}\n\nfunction formatMetric(metricObj) {\n  return {\n    text: metricObj.name,\n    expandable: false\n  };\n}\n\n/**\n * Custom formatter for template variables.\n * Default Grafana \"regex\" formatter returns\n * value1|value2\n * This formatter returns\n * (value1|value2)\n * This format needed for using in complex regex with\n * template variables, for example\n * /CPU $cpu_item.*time/ where $cpu_item is system,user,iowait\n */\nexport function zabbixTemplateFormat(value) {\n  if (typeof value === 'string') {\n    return utils.escapeRegex(value);\n  }\n\n  var escapedValues = _.map(value, utils.escapeRegex);\n  return '(' + escapedValues.join('|') + ')';\n}\n\nfunction zabbixItemIdsTemplateFormat(value) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  return value.join(',');\n}\n\n/**\n * If template variables are used in request, replace it using regex format\n * and wrap with '/' for proper multi-value work. Example:\n * $variable selected as a, b, c\n * We use filter $variable\n * $variable    -> a|b|c    -> /a|b|c/\n * /$variable/  -> /a|b|c/  -> /a|b|c/\n */\nfunction replaceTemplateVars(templateSrv, target, scopedVars) {\n  var replacedTarget = templateSrv.replace(target, scopedVars, zabbixTemplateFormat);\n  if (target !== replacedTarget && !utils.isRegex(replacedTarget)) {\n    replacedTarget = '/^' + replacedTarget + '$/';\n  }\n  return replacedTarget;\n}\n\nfunction filterEnabledTargets(targets) {\n  return _.filter(targets, target => {\n    return !(target.hide || !target.group || !target.host || !target.item);\n  });\n}\n\nfunction getTriggerThreshold(expression) {\n  let thresholdPattern = /.*[<>=]{1,2}([\\d\\.]+)/;\n  let finded_thresholds = expression.match(thresholdPattern);\n  if (finded_thresholds && finded_thresholds.length >= 2) {\n    let threshold = finded_thresholds[1];\n    threshold = Number(threshold);\n    return threshold;\n  } else {\n    return null;\n  }\n}\n\n// Fix for backward compatibility with lodash 2.4\nif (!_.includes) {_.includes = _.contains;}\nif (!_.keyBy) {_.keyBy = _.indexBy;}\n","import { QueryCtrl } from 'grafana/app/plugins/sdk';\nimport _ from 'lodash';\nimport * as c from './constants';\nimport * as utils from './utils';\nimport * as metricFunctions from './metricFunctions';\nimport * as migrations from './migrations';\n\nexport class ZabbixQueryController extends QueryCtrl {\n\n  /** @ngInject */\n  constructor($scope, $injector, $rootScope, $sce, templateSrv) {\n    super($scope, $injector);\n    this.zabbix = this.datasource.zabbix;\n\n    // Use custom format for template variables\n    this.replaceTemplateVars = this.datasource.replaceTemplateVars;\n    this.templateSrv = templateSrv;\n\n    this.editorModes = [\n      {value: 'num',       text: 'Metrics',     mode: c.MODE_METRICS},\n      {value: 'text',      text: 'Text',        mode: c.MODE_TEXT},\n      {value: 'itservice', text: 'IT Services', mode: c.MODE_ITSERVICE},\n      {value: 'itemid',    text: 'Item ID',     mode: c.MODE_ITEMID},\n      {value: 'triggers',  text: 'Triggers',    mode: c.MODE_TRIGGERS}\n    ];\n\n    this.$scope.editorMode = {\n      METRICS: c.MODE_METRICS,\n      TEXT: c.MODE_TEXT,\n      ITSERVICE: c.MODE_ITSERVICE,\n      ITEMID: c.MODE_ITEMID,\n      TRIGGERS: c.MODE_TRIGGERS\n    };\n\n    this.slaPropertyList = [\n      {name: \"Status\", property: \"status\"},\n      {name: \"SLA\", property: \"sla\"},\n      {name: \"OK time\", property: \"okTime\"},\n      {name: \"Problem time\", property: \"problemTime\"},\n      {name: \"Down time\", property: \"downtimeTime\"}\n    ];\n\n    this.ackFilters = [\n      {text: 'all triggers', value: 2},\n      {text: 'unacknowledged', value: 0},\n      {text: 'acknowledged', value: 1},\n    ];\n\n    this.resultFormats = [{ text: 'Time series', value: 'time_series' }, { text: 'Table', value: 'table' }];\n\n    this.triggerSeverity = c.TRIGGER_SEVERITY;\n\n    // Map functions for bs-typeahead\n    this.getGroupNames = _.bind(this.getMetricNames, this, 'groupList');\n    this.getHostNames = _.bind(this.getMetricNames, this, 'hostList', true);\n    this.getApplicationNames = _.bind(this.getMetricNames, this, 'appList');\n    this.getItemNames = _.bind(this.getMetricNames, this, 'itemList');\n    this.getITServices = _.bind(this.getMetricNames, this, 'itServiceList');\n    this.getVariables = _.bind(this.getTemplateVariables, this);\n\n    // Update metric suggestion when template variable was changed\n    $rootScope.$on('template-variable-value-updated', () => this.onVariableChange());\n\n    // Update metrics when item selected from dropdown\n    $scope.$on('typeahead-updated', () => {\n      this.onTargetBlur();\n    });\n\n    this.init = function() {\n      var target = this.target;\n\n      // Migrate old targets\n      target = migrations.migrate(target);\n\n      var scopeDefaults = {\n        metric: {},\n        oldTarget: _.cloneDeep(this.target),\n        queryOptionsText: this.renderQueryOptionsText()\n      };\n      _.defaults(this, scopeDefaults);\n\n      // Load default values\n      var targetDefaults = {\n        'mode': c.MODE_METRICS,\n        'group': { 'filter': \"\" },\n        'host': { 'filter': \"\" },\n        'application': { 'filter': \"\" },\n        'item': { 'filter': \"\" },\n        'functions': [],\n        'triggers': {\n          'count': true,\n          'minSeverity': 3,\n          'acknowledged': 2\n        },\n        'options': {\n          'showDisabledItems': false,\n          'skipEmptyValues': false\n        },\n        'table': {\n          'skipEmptyValues': false\n        }\n      };\n      _.defaults(target, targetDefaults);\n\n      // Create function instances from saved JSON\n      target.functions = _.map(target.functions, function(func) {\n        return metricFunctions.createFuncInstance(func.def, func.params);\n      });\n\n      if (target.mode === c.MODE_METRICS ||\n          target.mode === c.MODE_TEXT ||\n          target.mode === c.MODE_TRIGGERS) {\n        this.initFilters();\n      }\n      else if (target.mode === c.MODE_ITSERVICE) {\n        _.defaults(target, {slaProperty: {name: \"SLA\", property: \"sla\"}});\n        this.suggestITServices();\n      }\n    };\n\n    this.init();\n    this.queryOptionsText = this.renderQueryOptionsText();\n  }\n\n  initFilters() {\n    let itemtype = _.find(this.editorModes, {'mode': this.target.mode});\n    itemtype = itemtype ? itemtype.value : null;\n    return Promise.all([\n      this.suggestGroups(),\n      this.suggestHosts(),\n      this.suggestApps(),\n      this.suggestItems(itemtype)\n    ]);\n  }\n\n  // Get list of metric names for bs-typeahead directive\n  getMetricNames(metricList, addAllValue) {\n    let metrics = _.uniq(_.map(this.metric[metricList], 'name'));\n\n    // Add template variables\n    _.forEach(this.templateSrv.variables, variable => {\n      metrics.unshift('$' + variable.name);\n    });\n\n    if (addAllValue) {\n      metrics.unshift('/.*/');\n    }\n\n    return metrics;\n  }\n\n  getTemplateVariables() {\n    return _.map(this.templateSrv.variables, variable => {\n      return '$' + variable.name;\n    });\n  }\n\n  suggestGroups() {\n    return this.zabbix.getAllGroups()\n    .then(groups => {\n      this.metric.groupList = groups;\n      return groups;\n    });\n  }\n\n  suggestHosts() {\n    let groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    return this.zabbix.getAllHosts(groupFilter)\n    .then(hosts => {\n      this.metric.hostList = hosts;\n      return hosts;\n    });\n  }\n\n  suggestApps() {\n    let groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    let hostFilter = this.replaceTemplateVars(this.target.host.filter);\n    return this.zabbix.getAllApps(groupFilter, hostFilter)\n    .then(apps => {\n      this.metric.appList = apps;\n      return apps;\n    });\n  }\n\n  suggestItems(itemtype = 'num') {\n    let groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    let hostFilter = this.replaceTemplateVars(this.target.host.filter);\n    let appFilter = this.replaceTemplateVars(this.target.application.filter);\n    let options = {\n      itemtype: itemtype,\n      showDisabledItems: this.target.options.showDisabledItems\n    };\n\n    return this.zabbix\n    .getAllItems(groupFilter, hostFilter, appFilter, options)\n    .then(items => {\n      this.metric.itemList = items;\n      return items;\n    });\n  }\n\n  suggestITServices() {\n    return this.zabbix.getITService()\n    .then(itservices => {\n      this.metric.itServiceList = itservices;\n      return itservices;\n    });\n  }\n\n  isRegex(str) {\n    return utils.isRegex(str);\n  }\n\n  isVariable(str) {\n    return utils.isTemplateVariable(str, this.templateSrv.variables);\n  }\n\n  onTargetBlur() {\n    var newTarget = _.cloneDeep(this.target);\n    if (!_.isEqual(this.oldTarget, this.target)) {\n      this.oldTarget = newTarget;\n      this.targetChanged();\n    }\n  }\n\n  onVariableChange() {\n    if (this.isContainsVariables()) {\n      this.targetChanged();\n    }\n  }\n\n  /**\n   * Check query for template variables\n   */\n  isContainsVariables() {\n    return _.some(['group', 'host', 'application'], field => {\n      if (this.target[field] && this.target[field].filter) {\n        return utils.isTemplateVariable(this.target[field].filter, this.templateSrv.variables);\n      } else {\n        return false;\n      }\n    });\n  }\n\n  parseTarget() {\n    // Parse target\n  }\n\n  // Validate target and set validation info\n  validateTarget() {\n    // validate\n  }\n\n  targetChanged() {\n    this.initFilters();\n    this.parseTarget();\n    this.panelCtrl.refresh();\n  }\n\n  addFunction(funcDef) {\n    var newFunc = metricFunctions.createFuncInstance(funcDef);\n    newFunc.added = true;\n    this.target.functions.push(newFunc);\n\n    this.moveAliasFuncLast();\n\n    if (newFunc.params.length && newFunc.added ||\n        newFunc.def.params.length === 0) {\n      this.targetChanged();\n    }\n  }\n\n  removeFunction(func) {\n    this.target.functions = _.without(this.target.functions, func);\n    this.targetChanged();\n  }\n\n  moveFunction(func, offset) {\n    const index = this.target.functions.indexOf(func);\n    _.move(this.target.functions, index, index + offset);\n    this.targetChanged();\n  }\n\n  moveAliasFuncLast() {\n    var aliasFunc = _.find(this.target.functions, func => {\n      return func.def.category === 'Alias';\n    });\n\n    if (aliasFunc) {\n      this.target.functions = _.without(this.target.functions, aliasFunc);\n      this.target.functions.push(aliasFunc);\n    }\n  }\n\n  toggleQueryOptions() {\n    this.showQueryOptions = !this.showQueryOptions;\n  }\n\n  onQueryOptionChange() {\n    this.queryOptionsText = this.renderQueryOptionsText();\n    this.onTargetBlur();\n  }\n\n  renderQueryOptionsText() {\n    var optionsMap = {\n      showDisabledItems: \"Show disabled items\",\n      skipEmptyValues: \"Skip empty values\"\n    };\n    var options = [];\n    _.forOwn(this.target.options, (value, key) => {\n      if (value) {\n        if (value === true) {\n          // Show only option name (if enabled) for boolean options\n          options.push(optionsMap[key]);\n        } else {\n          // Show \"option = value\" for another options\n          options.push(optionsMap[key] + \" = \" + value);\n        }\n      }\n    });\n    return \"Options: \" + options.join(', ');\n  }\n\n  /**\n   * Switch query editor to specified mode.\n   * Modes:\n   *  0 - items\n   *  1 - IT services\n   *  2 - Text metrics\n   */\n  switchEditorMode(mode) {\n    this.target.mode = mode;\n    this.init();\n    this.targetChanged();\n  }\n}\n","import _ from 'lodash';\nimport { getDataSourceSrv } from '@grafana/runtime';\nimport { migrateDSConfig } from './migrations';\n\nconst SUPPORTED_SQL_DS = ['mysql', 'postgres', 'influxdb'];\n\nconst zabbixVersions = [\n  { name: '2.x', value: 2 },\n  { name: '3.x', value: 3 },\n  { name: '4.x', value: 4 },\n];\n\nconst defaultConfig = {\n  trends: false,\n  dbConnectionEnable: false,\n  dbConnectionDatasourceId: null,\n  alerting: false,\n  addThresholds: false,\n  alertingMinSeverity: 3,\n  disableReadOnlyUsersAck: false,\n  zabbixVersion: 3,\n};\n\nexport class ZabbixDSConfigController {\n\n  /** @ngInject */\n  constructor() {\n    this.current.jsonData = migrateDSConfig(this.current.jsonData);\n    _.defaults(this.current.jsonData, defaultConfig);\n\n    this.dbConnectionDatasourceId = this.current.jsonData.dbConnectionDatasourceId;\n    this.dbDataSources = this.getSupportedDBDataSources();\n    this.zabbixVersions = _.cloneDeep(zabbixVersions);\n    this.autoDetectZabbixVersion();\n    if (!this.dbConnectionDatasourceId) {\n      this.loadCurrentDBDatasource();\n    }\n  }\n\n  getSupportedDBDataSources() {\n    let datasources = getDataSourceSrv().getAll();\n    return _.filter(datasources, ds => {\n      return _.includes(SUPPORTED_SQL_DS, ds.type);\n    });\n  }\n\n  getCurrentDatasourceType() {\n    const dsId = this.dbConnectionDatasourceId;\n    const currentDs = _.find(this.dbDataSources, { 'id': dsId });\n    return currentDs ? currentDs.type : null;\n  }\n\n  loadCurrentDBDatasource() {\n    const dsName= this.current.jsonData.dbConnectionDatasourceName;\n    getDataSourceSrv().loadDatasource(dsName)\n    .then(ds => {\n      if (ds) {\n        this.dbConnectionDatasourceId = ds.id;\n      }\n    });\n  }\n\n  autoDetectZabbixVersion() {\n    if (!this.current.id) {\n      return;\n    }\n\n    getDataSourceSrv().loadDatasource(this.current.name)\n    .then(ds => {\n      return ds.getVersion();\n    })\n    .then(version => {\n      if (version) {\n        if (!_.find(zabbixVersions, ['value', version])) {\n          this.zabbixVersions.push({ name: version + '.x', value: version });\n        }\n        this.current.jsonData.zabbixVersion = version;\n      }\n    });\n  }\n\n  onDBConnectionDatasourceChange() {\n    this.current.jsonData.dbConnectionDatasourceId = this.dbConnectionDatasourceId;\n  }\n}\n","import React, { FC } from 'react';\nimport { css, cx } from 'emotion';\nimport { Themeable, withTheme, Input, EventsWithValidation, ValidationEvents } from '@grafana/ui';\nimport { isRegex, variableRegex } from '../utils';\nimport { GrafanaTheme } from '@grafana/data';\n\nconst variablePattern = RegExp(`^${variableRegex.source}`);\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  inputRegex: css`\n    color: ${theme.colors.orange}\n  `,\n  inputVariable: css`\n    color: ${theme.colors.variable}\n  `,\n});\n\nconst zabbixInputValidationEvents: ValidationEvents = {\n  [EventsWithValidation.onBlur]: [\n    {\n      rule: value => {\n        if (!value) {\n          return true;\n        }\n        if (value.length > 1 && value[0] === '/') {\n          if (value[value.length - 1] !== '/') {\n            return false;\n          }\n        }\n        return true;\n      },\n      errorMessage: 'Not a valid regex',\n    },\n    {\n      rule: value => {\n        if (value === '*') {\n          return false;\n        }\n        return true;\n      },\n      errorMessage: 'Wildcards not supported. Use /.*/ instead',\n    },\n  ],\n};\n\ninterface Props extends React.ComponentProps<typeof Input>, Themeable {\n}\n\nconst UnthemedZabbixInput: FC<Props> = ({ theme, value, ref, validationEvents, ...restProps }) => {\n  const styles = getStyles(theme);\n\n  let inputClass;\n  if (variablePattern.test(value as string)) {\n    inputClass = styles.inputVariable;\n  }\n  if (isRegex(value)) {\n    inputClass = styles.inputRegex;\n  }\n\n  return (\n    <Input\n      className={inputClass}\n      value={value}\n      validationEvents={zabbixInputValidationEvents}\n      {...restProps}\n    />\n  );\n};\n\nexport const ZabbixInput = withTheme(UnthemedZabbixInput);\n","import React, { PureComponent } from 'react';\nimport { parseLegacyVariableQuery } from '../utils';\nimport { Select, Input, AsyncSelect, FormLabel } from '@grafana/ui';\nimport { SelectableValue } from '@grafana/data';\nimport { VariableQuery, VariableQueryTypes, VariableQueryProps, VariableQueryData } from '../types';\nimport { ZabbixInput } from './ZabbixInput';\n\nexport class ZabbixVariableQueryEditor extends PureComponent<VariableQueryProps, VariableQueryData> {\n  queryTypes: Array<SelectableValue<VariableQueryTypes>> = [\n    { value: VariableQueryTypes.Group, label: 'Group'},\n    { value: VariableQueryTypes.Host, label: 'Host' },\n    { value: VariableQueryTypes.Application, label: 'Application' },\n    { value: VariableQueryTypes.Item, label: 'Item' },\n  ];\n\n  defaults: VariableQueryData = {\n    selectedQueryType: { value: VariableQueryTypes.Group, label: 'Group' },\n    queryType: VariableQueryTypes.Group,\n    group: '/.*/',\n    host: '',\n    application: '',\n    item: '',\n  };\n\n  constructor(props: VariableQueryProps) {\n    super(props);\n\n    if (this.props.query && typeof this.props.query === 'string') {\n      // Backward compatibility\n      const query = parseLegacyVariableQuery(this.props.query);\n      const selectedQueryType = this.getSelectedQueryType(query.queryType);\n      this.state = {\n        selectedQueryType,\n        legacyQuery: this.props.query,\n        ...query\n      };\n    } else if (this.props.query) {\n      const query = (this.props.query as VariableQuery);\n      const selectedQueryType = this.getSelectedQueryType(query.queryType);\n      this.state = {\n        ...this.defaults,\n        ...query,\n        selectedQueryType,\n      };\n    } else {\n      this.state = this.defaults;\n    }\n  }\n\n  getSelectedQueryType(queryType: VariableQueryTypes) {\n    return this.queryTypes.find(q => q.value === queryType);\n  }\n\n  handleQueryUpdate = (evt: React.ChangeEvent<HTMLInputElement>, prop: string) => {\n    const value = evt.currentTarget.value;\n    this.setState((prevState: VariableQueryData) => {\n      const newQuery = {\n        ...prevState,\n      };\n      newQuery[prop] = value;\n\n      return {\n        ...newQuery,\n      };\n    });\n  }\n\n  handleQueryChange = () => {\n    const { queryType, group, host, application, item } = this.state;\n    const queryModel = { queryType, group, host, application, item };\n    this.props.onChange(queryModel, `Zabbix - ${queryType}`);\n  }\n\n  handleQueryTypeChange = (selectedItem: SelectableValue<VariableQueryTypes>) => {\n    this.setState({\n      ...this.state,\n      selectedQueryType: selectedItem,\n      queryType: selectedItem.value,\n    });\n\n    const { group, host, application, item } = this.state;\n    const queryType = selectedItem.value;\n    const queryModel = { queryType, group, host, application, item };\n    this.props.onChange(queryModel, `Zabbix - ${queryType}`);\n  }\n\n  render() {\n    const { selectedQueryType, legacyQuery, group, host, application, item } = this.state;\n\n    return (\n      <>\n        <div className=\"gf-form max-width-21\">\n          <FormLabel width={10}>Query Type</FormLabel>\n          <Select\n            width={11}\n            value={selectedQueryType}\n            options={this.queryTypes}\n            onChange={this.handleQueryTypeChange}\n          />\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form max-width-30\">\n            <FormLabel width={10}>Group</FormLabel>\n            <ZabbixInput\n              value={group}\n              onChange={evt => this.handleQueryUpdate(evt, 'group')}\n              onBlur={this.handleQueryChange}\n            />\n          </div>\n          {selectedQueryType.value !== VariableQueryTypes.Group &&\n            <div className=\"gf-form max-width-30\">\n              <FormLabel width={10}>Host</FormLabel>\n              <ZabbixInput\n                value={host}\n                onChange={evt => this.handleQueryUpdate(evt, 'host')}\n                onBlur={this.handleQueryChange}\n              />\n            </div>\n          }\n        </div>\n        {(selectedQueryType.value === VariableQueryTypes.Application ||\n          selectedQueryType.value === VariableQueryTypes.Item) &&\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form max-width-30\">\n              <FormLabel width={10}>Application</FormLabel>\n              <ZabbixInput\n                value={application}\n                onChange={evt => this.handleQueryUpdate(evt, 'application')}\n                onBlur={this.handleQueryChange}\n              />\n            </div>\n            {selectedQueryType.value === VariableQueryTypes.Item &&\n              <div className=\"gf-form max-width-30\">\n                <FormLabel width={10}>Item</FormLabel>\n                <ZabbixInput\n                  value={item}\n                  onChange={evt => this.handleQueryUpdate(evt, 'item')}\n                  onBlur={this.handleQueryChange}\n                />\n              </div>\n            }\n          </div>\n        }\n\n        {legacyQuery &&\n          <div className=\"gf-form\">\n            <FormLabel width={10} tooltip=\"Original query string, read-only\">Legacy Query</FormLabel>\n            <Input\n              value={legacyQuery}\n              readOnly={true}\n            />\n          </div>\n        }\n      </>\n    );\n  }\n}\n","import _ from 'lodash';\nimport $ from 'jquery';\nimport angular from 'angular';\n\nclass ZabbixAlertingService {\n\n  /** @ngInject */\n  constructor(dashboardSrv) {\n    this.dashboardSrv = dashboardSrv;\n  }\n\n  isFullScreen() {\n    return this.getDashboardModel().meta.fullscreen;\n  }\n\n  setPanelAlertState(panelId, alertState) {\n    let panelIndex;\n\n    let panelContainers = _.filter($('.panel-container'), elem => {\n      return elem.clientHeight && elem.clientWidth;\n    });\n\n    let panelModels = this.getPanelModels();\n\n    if (this.isFullScreen()) {\n      panelIndex = 0;\n    } else {\n      panelIndex = _.findIndex(panelModels, panel => {\n        return panel.id === panelId;\n      });\n    }\n\n    // Don't apply alert styles to .panel-container--absolute (it rewrites position from absolute to relative)\n    if (panelIndex >= 0 && !panelContainers[panelIndex].className.includes('panel-container--absolute')) {\n      let alertClass = \"panel-has-alert panel-alert-state--ok panel-alert-state--alerting\";\n      $(panelContainers[panelIndex]).removeClass(alertClass);\n\n      if (alertState) {\n        alertClass = \"panel-has-alert panel-alert-state--\" + alertState;\n        $(panelContainers[panelIndex]).addClass(alertClass);\n      }\n    }\n  }\n\n  getDashboardModel() {\n    return this.dashboardSrv.dash || this.dashboardSrv.dashboard;\n  }\n\n  getPanelModels() {\n    return _.filter(this.getDashboardModel().panels, panel => panel.type !== 'row');\n  }\n\n  getPanelModel(panelId) {\n    let panelModels = this.getPanelModels();\n\n    return _.find(panelModels, panel => {\n      return panel.id === panelId;\n    });\n  }\n\n  setPanelThreshold(panelId, threshold) {\n    let panel = this.getPanelModel(panelId);\n    let containsThreshold = _.find(panel.thresholds, {value: threshold});\n\n    if (panel && panel.type === \"graph\" && !containsThreshold) {\n      let thresholdOptions = {\n        colorMode : \"custom\",\n        fill : false,\n        line : true,\n        lineColor: \"rgb(255, 0, 0)\",\n        op: \"gt\",\n        value: threshold,\n        source: \"zabbix\"\n      };\n\n      panel.thresholds.push(thresholdOptions);\n    }\n  }\n\n  removeZabbixThreshold(panelId) {\n    let panel = this.getPanelModel(panelId);\n\n    if (panel && panel.type === \"graph\") {\n      panel.thresholds = _.filter(panel.thresholds, threshold => {\n        return threshold.source !== \"zabbix\";\n      });\n    }\n  }\n\n}\n\nangular\n  .module('grafana.services')\n  .service('zabbixAlertingSrv', ZabbixAlertingService);\n","import angular from 'angular';\nimport _ from 'lodash';\nimport $ from 'jquery';\nimport * as metricFunctions from './metricFunctions';\n\nangular\n  .module('grafana.directives')\n  .directive('addMetricFunction',\n\n  /** @ngInject */\n  function($compile) {\n    var inputTemplate = '<input type=\"text\"'+\n                          ' class=\"gf-form-input\"' +\n                          ' spellcheck=\"false\" style=\"display:none\"></input>';\n\n    var buttonTemplate = '<a  class=\"gf-form-label tight-form-func dropdown-toggle query-part\"' +\n                            ' tabindex=\"1\" gf-dropdown=\"functionMenu\" data-toggle=\"dropdown\">' +\n                            '<i class=\"fa fa-plus\"></i></a>';\n\n    return {\n      link: function($scope, elem) {\n        var categories = metricFunctions.getCategories();\n        var allFunctions = getAllFunctionNames(categories);\n\n        $scope.functionMenu = createFunctionDropDownMenu(categories);\n\n        var $input = $(inputTemplate);\n        var $button = $(buttonTemplate);\n        $input.appendTo(elem);\n        $button.appendTo(elem);\n\n        $input.attr('data-provide', 'typeahead');\n        $input.typeahead({\n          source: allFunctions,\n          minLength: 1,\n          items: 10,\n          updater: function (value) {\n            var funcDef = metricFunctions.getFuncDef(value);\n            if (!funcDef) {\n              // try find close match\n              value = value.toLowerCase();\n              funcDef = _.find(allFunctions, function(funcName) {\n                return funcName.toLowerCase().indexOf(value) === 0;\n              });\n\n              if (!funcDef) { return; }\n            }\n\n            $scope.$apply(function() {\n              $scope.ctrl.addFunction(funcDef);\n            });\n\n            $input.trigger('blur');\n            return '';\n          }\n        });\n\n        $button.click(function() {\n          $button.hide();\n          $input.show();\n          $input.focus();\n        });\n\n        $input.keyup(function() {\n          elem.toggleClass('open', $input.val() === '');\n        });\n\n        $input.blur(function() {\n          // clicking the function dropdown menu won't\n          // work if you remove class at once\n          setTimeout(function() {\n            $input.val('');\n            $input.hide();\n            $button.show();\n            elem.removeClass('open');\n          }, 200);\n        });\n\n        $compile(elem.contents())($scope);\n      }\n    };\n  });\n\nfunction getAllFunctionNames(categories) {\n  return _.reduce(categories, function(list, category) {\n    _.each(category, function(func) {\n      list.push(func.name);\n    });\n    return list;\n  }, []);\n}\n\nfunction createFunctionDropDownMenu(categories) {\n  return _.map(categories, function(list, category) {\n    return {\n      text: category,\n      submenu: _.map(list, function(value) {\n        return {\n          text: value.name,\n          click: \"ctrl.addFunction('\" + value.name + \"')\",\n        };\n      })\n    };\n  });\n}\n\n","import coreModule from 'grafana/app/core/core_module';\n\nexport function react2AngularDirective(name: string, component: any, options: any) {\n  coreModule.directive(name, [\n    'reactDirective',\n    reactDirective => {\n      return reactDirective(component, options);\n    },\n  ]);\n}\n","import React from 'react';\n\nconst DOCS_FUNC_REF_URL = 'https://alexanderzobnin.github.io/grafana-zabbix/reference/functions/';\n\nexport interface FunctionDescriptor {\n  text: string;\n  params: string[];\n  def: {\n    category: string;\n    defaultParams: string[];\n    description?: string;\n    fake: boolean;\n    name: string;\n    params: string[];\n  };\n}\n\nexport interface FunctionEditorControlsProps {\n  onMoveLeft: (func: FunctionDescriptor) => void;\n  onMoveRight: (func: FunctionDescriptor) => void;\n  onRemove: (func: FunctionDescriptor) => void;\n}\n\nconst FunctionHelpButton = (props: { description: string; name: string; onDescriptionShow: () => void }) => {\n  if (props.description) {\n    return <span className=\"pointer fa fa-question-circle\" onClick={props.onDescriptionShow} />;\n  }\n\n  return (\n    <span\n      className=\"pointer fa fa-question-circle\"\n      onClick={() => {\n        window.open(\n          DOCS_FUNC_REF_URL + '#' + props.name,\n          '_blank'\n        );\n      }}\n    />\n  );\n};\n\nexport const FunctionEditorControls = (\n  props: FunctionEditorControlsProps & {\n    func: FunctionDescriptor;\n    onDescriptionShow: () => void;\n  }\n) => {\n  const { func, onMoveLeft, onMoveRight, onRemove, onDescriptionShow } = props;\n  return (\n    <div\n      style={{\n        display: 'flex',\n        width: '60px',\n        justifyContent: 'space-between',\n      }}\n    >\n      <span className=\"pointer fa fa-arrow-left\" onClick={() => onMoveLeft(func)} />\n      <FunctionHelpButton\n        name={func.def.name}\n        description={func.def.description}\n        onDescriptionShow={onDescriptionShow}\n      />\n      <span className=\"pointer fa fa-remove\" onClick={() => onRemove(func)} />\n      <span className=\"pointer fa fa-arrow-right\" onClick={() => onMoveRight(func)} />\n    </div>\n  );\n};\n","import React from 'react';\n// import rst2html from 'rst2html';\nimport { FunctionDescriptor, FunctionEditorControlsProps, FunctionEditorControls } from './FunctionEditorControls';\n\n// @ts-ignore\nimport { PopoverController, Popover } from '@grafana/ui';\n\ninterface FunctionEditorProps extends FunctionEditorControlsProps {\n  func: FunctionDescriptor;\n}\n\ninterface FunctionEditorState {\n  showingDescription: boolean;\n}\n\nclass FunctionEditor extends React.PureComponent<FunctionEditorProps, FunctionEditorState> {\n  private triggerRef = React.createRef<HTMLSpanElement>();\n\n  constructor(props: FunctionEditorProps) {\n    super(props);\n\n    this.state = {\n      showingDescription: false,\n    };\n  }\n\n  renderContent = ({ updatePopperPosition }) => {\n    const {\n      onMoveLeft,\n      onMoveRight,\n      func: {\n        def: { name, description },\n      },\n    } = this.props;\n    const { showingDescription } = this.state;\n\n    if (showingDescription) {\n      return (\n        <div style={{ overflow: 'auto', maxHeight: '30rem', textAlign: 'left', fontWeight: 'normal' }}>\n          <h4 style={{ color: 'white' }}> {name} </h4>\n          <div>{description}</div>\n          />\n        </div>\n      );\n    }\n\n    return (\n      <FunctionEditorControls\n        {...this.props}\n        onMoveLeft={() => {\n          onMoveLeft(this.props.func);\n          updatePopperPosition();\n        }}\n        onMoveRight={() => {\n          onMoveRight(this.props.func);\n          updatePopperPosition();\n        }}\n        onDescriptionShow={() => {\n          this.setState({ showingDescription: true }, () => {\n            updatePopperPosition();\n          });\n        }}\n      />\n    );\n  };\n\n  render() {\n    return (\n      <PopoverController content={this.renderContent} placement=\"top\" hideAfter={300}>\n        {(showPopper, hidePopper, popperProps) => {\n          return (\n            <>\n              {this.triggerRef && (\n                <Popover\n                  {...popperProps}\n                  referenceElement={this.triggerRef.current}\n                  wrapperClassName=\"popper\"\n                  className=\"popper__background\"\n                  onMouseLeave={() => {\n                    this.setState({ showingDescription: false });\n                    hidePopper();\n                  }}\n                  onMouseEnter={showPopper}\n                  renderArrow={({ arrowProps, placement }) => (\n                    <div className=\"popper__arrow\" data-placement={placement} {...arrowProps} />\n                  )}\n                />\n              )}\n\n              <span\n                ref={this.triggerRef}\n                onClick={popperProps.show ? hidePopper : showPopper}\n                onMouseLeave={() => {\n                  hidePopper();\n                  this.setState({ showingDescription: false });\n                }}\n                style={{ cursor: 'pointer' }}\n              >\n                {this.props.func.def.name}\n              </span>\n            </>\n          );\n        }}\n      </PopoverController>\n    );\n  }\n}\n\nexport { FunctionEditor };\n","import coreModule from 'grafana/app/core/core_module';\nimport _ from 'lodash';\nimport $ from 'jquery';\nimport { react2AngularDirective } from './react2angular';\nimport { FunctionEditor } from './components/FunctionEditor';\n\n/** @ngInject */\nexport function zabbixFunctionEditor($compile, templateSrv) {\n  const funcSpanTemplate = `\n    <zbx-function-editor\n      func=\"func\"\n      onRemove=\"ctrl.handleRemoveFunction\"\n      onMoveLeft=\"ctrl.handleMoveLeft\"\n      onMoveRight=\"ctrl.handleMoveRight\"\n    /><span>(</span>\n  `;\n  const paramTemplate =\n    '<input type=\"text\" style=\"display:none\"' + ' class=\"input-small tight-form-func-param\"></input>';\n\n  return {\n    restrict: 'A',\n    link: function postLink($scope, elem) {\n      const $funcLink = $(funcSpanTemplate);\n      const ctrl = $scope.ctrl;\n      const func = $scope.func;\n      let scheduledRelink = false;\n      let paramCountAtLink = 0;\n      let cancelBlur = null;\n\n      ctrl.handleRemoveFunction = func => {\n        ctrl.removeFunction(func);\n      };\n\n      ctrl.handleMoveLeft = func => {\n        ctrl.moveFunction(func, -1);\n      };\n\n      ctrl.handleMoveRight = func => {\n        ctrl.moveFunction(func, 1);\n      };\n\n      function clickFuncParam(this: any, paramIndex) {\n        /*jshint validthis:true */\n\n        const $link = $(this);\n        const $comma = $link.prev('.comma');\n        const $input = $link.next();\n\n        $input.val(func.params[paramIndex]);\n\n        $comma.removeClass('query-part__last');\n        $link.hide();\n        $input.show();\n        $input.focus();\n        $input.select();\n\n        const typeahead = $input.data('typeahead');\n        if (typeahead) {\n          $input.val('');\n          typeahead.lookup();\n        }\n      }\n\n      function scheduledRelinkIfNeeded() {\n        if (paramCountAtLink === func.params.length) {\n          return;\n        }\n\n        if (!scheduledRelink) {\n          scheduledRelink = true;\n          setTimeout(() => {\n            relink();\n            scheduledRelink = false;\n          }, 200);\n        }\n      }\n\n      function paramDef(index) {\n        if (index < func.def.params.length) {\n          return func.def.params[index];\n        }\n        if ((_.last(func.def.params) as any).multiple) {\n          return _.assign({}, _.last(func.def.params), { optional: true });\n        }\n        return {};\n      }\n\n      function switchToLink(inputElem, paramIndex) {\n        /*jshint validthis:true */\n        const $input = $(inputElem);\n\n        clearTimeout(cancelBlur);\n        cancelBlur = null;\n\n        const $link = $input.prev();\n        const $comma = $link.prev('.comma');\n        const newValue = $input.val();\n\n        // remove optional empty params\n        if (newValue !== '' || paramDef(paramIndex).optional) {\n          func.updateParam(newValue, paramIndex);\n          $link.html(newValue ? templateSrv.highlightVariablesAsHtml(newValue) : '&nbsp;');\n        }\n\n        scheduledRelinkIfNeeded();\n\n        $scope.$apply(() => {\n          ctrl.targetChanged();\n        });\n\n        if ($link.hasClass('query-part__last') && newValue === '') {\n          $comma.addClass('query-part__last');\n        } else {\n          $link.removeClass('query-part__last');\n        }\n\n        $input.hide();\n        $link.show();\n      }\n\n      // this = input element\n      function inputBlur(this: any, paramIndex) {\n        /*jshint validthis:true */\n        const inputElem = this;\n        // happens long before the click event on the typeahead options\n        // need to have long delay because the blur\n        cancelBlur = setTimeout(() => {\n          switchToLink(inputElem, paramIndex);\n        }, 200);\n      }\n\n      function inputKeyPress(this: any, paramIndex, e) {\n        /*jshint validthis:true */\n        if (e.which === 13) {\n          $(this).blur();\n        }\n      }\n\n      function inputKeyDown(this: any) {\n        /*jshint validthis:true */\n        this.style.width = (3 + this.value.length) * 8 + 'px';\n      }\n\n      function addTypeahead($input, paramIndex) {\n        $input.attr('data-provide', 'typeahead');\n\n        let options = paramDef(paramIndex).options;\n        if (paramDef(paramIndex).type === 'int' || paramDef(paramIndex).type === 'float') {\n          options = _.map(options, val => {\n            return val.toString();\n          });\n        }\n\n        $input.typeahead({\n          source: options,\n          minLength: 0,\n          items: 20,\n          updater: value => {\n            $input.val(value);\n            switchToLink($input[0], paramIndex);\n            return value;\n          },\n        });\n\n        const typeahead = $input.data('typeahead');\n        typeahead.lookup = function() {\n          this.query = this.$element.val() || '';\n          return this.process(this.source);\n        };\n      }\n\n      function addElementsAndCompile() {\n        $funcLink.appendTo(elem);\n\n        const defParams: any = _.clone(func.def.params);\n        const lastParam: any = _.last(func.def.params);\n\n        while (func.params.length >= defParams.length && lastParam && lastParam.multiple) {\n          defParams.push(_.assign({}, lastParam, { optional: true }));\n        }\n\n        _.each(defParams, (param: any, index: number) => {\n          if (param.optional && func.params.length < index) {\n            return false;\n          }\n\n          let paramValue = templateSrv.highlightVariablesAsHtml(func.params[index]);\n          const hasValue = paramValue !== null && paramValue !== undefined;\n\n          const last = index >= func.params.length - 1 && param.optional && !hasValue;\n          if (last && param.multiple) {\n            paramValue = '+';\n          }\n\n          if (index > 0) {\n            $('<span class=\"comma' + (last ? ' query-part__last' : '') + '\">, </span>').appendTo(elem);\n          }\n\n          const $paramLink = $(\n            '<a ng-click=\"\" class=\"graphite-func-param-link' +\n              (last ? ' query-part__last' : '') +\n              '\">' +\n              (hasValue ? paramValue : '&nbsp;') +\n              '</a>'\n          );\n          const $input = $(paramTemplate);\n          $input.attr('placeholder', param.name);\n\n          paramCountAtLink++;\n\n          $paramLink.appendTo(elem);\n          $input.appendTo(elem);\n\n          $input.blur(_.partial(inputBlur, index));\n          $input.keyup(inputKeyDown);\n          $input.keypress(_.partial(inputKeyPress, index));\n          $paramLink.click(_.partial(clickFuncParam, index));\n\n          if (param.options) {\n            addTypeahead($input, index);\n          }\n\n          return true;\n        });\n\n        $('<span>)</span>').appendTo(elem);\n\n        $compile(elem.contents())($scope);\n      }\n\n      function ifJustAddedFocusFirstParam() {\n        if ($scope.func.added) {\n          $scope.func.added = false;\n          setTimeout(() => {\n            elem\n              .find('.graphite-func-param-link')\n              .first()\n              .click();\n          }, 10);\n        }\n      }\n\n      function relink() {\n        elem.children().remove();\n        addElementsAndCompile();\n        ifJustAddedFocusFirstParam();\n      }\n\n      relink();\n    },\n  };\n}\n\ncoreModule.directive('zabbixFunctionEditor', zabbixFunctionEditor);\n\nreact2AngularDirective('zbxFunctionEditor', FunctionEditor, ['func', 'onRemove', 'onMoveLeft', 'onMoveRight']);\n","import { loadPluginCss } from 'grafana/app/plugins/sdk';\nimport { ZabbixDatasource } from './datasource';\nimport { ZabbixQueryController } from './query.controller';\nimport { ZabbixDSConfigController } from './config.controller';\nimport { ZabbixVariableQueryEditor } from './components/VariableQueryEditor';\nimport './zabbixAlerting.service.js';\nimport './add-metric-function.directive';\nimport './metric-function-editor.directive';\n\nclass ZabbixQueryOptionsController {\n  static templateUrl = 'datasource-zabbix/partials/query.options.html';\n}\n\nclass ZabbixAnnotationsQueryController {\n  static templateUrl = 'datasource-zabbix/partials/annotations.editor.html';\n}\n\nZabbixQueryController.templateUrl = 'datasource-zabbix/partials/query.editor.html';\nZabbixDSConfigController.templateUrl = 'datasource-zabbix/partials/config.html';\n\nloadPluginCss({\n  dark: 'plugins/alexanderzobnin-zabbix-app/css/grafana-zabbix.dark.css',\n  light: 'plugins/alexanderzobnin-zabbix-app/css/grafana-zabbix.light.css'\n});\n\nexport {\n  ZabbixDatasource as Datasource,\n  ZabbixDSConfigController as ConfigCtrl,\n  ZabbixQueryController as QueryCtrl,\n  ZabbixQueryOptionsController as QueryOptionsCtrl,\n  ZabbixAnnotationsQueryController as AnnotationsQueryCtrl,\n  ZabbixVariableQueryEditor as VariableQueryEditor,\n};\n"],"sourceRoot":""}